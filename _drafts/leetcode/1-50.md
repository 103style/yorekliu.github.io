---
title: "LeetCode(1)"
excerpt: "LeetCode1-50总结"
categories:
  - Algorithm
tags:
  - LeetCode
  - Array  
  - HashTable
  - LinkedList
  - String
  - Binary Search
  - Divide and Conquer
  - Dynamic Programming
toc: true
toc_label: "目录"
toc_icon: "heart"
---

### 1. Two Sum

[Array](/tags/#array){: .btn .btn--inverse } [HashTable](/tags/#hashtable){: .btn .btn--inverse }

Given an array of integers, return indices of the two numbers such that they add up to a specific target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

**Example:**

Given nums = [2, 7, 11, 15], target = 9,  
Because nums[**0**] + nums[**1**] = 2 + 7 = 9,  
return [**0**, **1**].   
{: .notice }

**Brute Force**
```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            for (int j = i + 1; j < nums.length; j++) {
                if (nums[i] + nums[j] == target) {
                    return new int[]{i, j};
                }
            }
        }

        return new int[]{};
    }
}
```

**One-pass Hash Table**
```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[] { map.get(complement), i };
        }
        map.put(nums[i], i);
    }
    throw new IllegalArgumentException("No two sum solution");
}
```

可以常规解法，也可以使用HashMap的特性。
{: .notice--success }

### 2. Add Two Numbers

[LinkedList](/tags/#linkedlist){: .btn .btn--inverse }

You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order** and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

**Example:**

**Input:** (2 -> 4 -> 3) + (5 -> 6 -> 4)  
**Output:** 7 -> 0 -> 8  
**Explanation:** 342 + 465 = 807.
{: .notice }

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode result = new ListNode(0);
        ListNode p = result;
        int carry = 0, bit = 0;
        while (l1 != null || l2 != null || carry != 0) {
            bit = ((l1 == null) ? 0 : l1.val) + ((l2 == null) ? 0 : l2.val) + carry;
            carry = bit / 10;
            p.next = new ListNode(bit % 10);
            p = p.next;
            l1 = (l1 == null) ? null : l1.next;
            l2 = (l2 == null) ? null : l2.next;
        }

        return result.next;
    }
}
```

该题几个要点：  
1.数字是逆序存储的，即头节点是个位，这就意味着直接算，进位进到next就可以了  
2.最后一个节点可能是进位进来的1  
3.l1、l2不一定长度相等  
{: .notice--success }

### 3. Longest Substring Without Repeating Characters

[HashTable](/tags/#hashtable){: .btn .btn--inverse } [String](/tags/#string){: .btn .btn--inverse }

Given a string, find the length of the **longest substring** without repeating characters.

**Example:**

Given `"abcabcbb"`, the answer is `"abc"`, which the length is 3.  
Given `"bbbbb"`, the answer is `"b"`, with the length of 1.  
Given `"pwwkew"`, the answer is `"wke"`, with the length of 3. Note that the answer must be a substring, `"pwke"` is a subsequence and not a substring.
{: .notice }

**Sliding Window**
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int i = 0, j = 0, ans = 0, n = s.length();
        Set<Character> set = new HashSet();

        while (i < n && j < n) {
            if (!set.contains(s.charAt(j))) {
                set.add(s.charAt(j++));
                ans = Math.max(ans, j - i);
            } else {
                set.remove(s.charAt(i++));
            }
        }

        return ans;
    }
}
```

使用滑动窗口方法解，将[i, j]里面的字母用HashSet存储  
若a[j]不在Set里面，set.add(s.charAt(j++))  
否则set.remove(s.charAt(i++))
{: .notice--success }

### 4. Median of Two Sorted Arrays

[Array](/tags/#array){: .btn .btn--inverse } [Binary Search](/tags/#binary-search){: .btn .btn--inverse } [Divide and Conquer](/tags/#divide-and-conquer){: .btn .btn--inverse }

There are two sorted arrays **nums1** and **nums2** of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

You may assume **nums1** and **nums2** cannot be both empty.

**Example 1:**

nums1 = [1, 3]  
nums2 = [2]  
The median is 2.0
{: .notice }

**Example 2:**

nums1 = [1, 2]  
nums2 = [3, 4]  
The median is (2 + 3)/2 = 2.5
{: .notice }

**Solution**
```java
public class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        // Deal with invalid corner case.
        if (nums1 == null || nums2 == null || nums1.length == 0 || nums2.length == 0) return 0.0;

        int m = nums1.length, n = nums2.length;
        int l = (m + n + 1) / 2; //left half of the combined median
        int r = (m + n + 2) / 2; //right half of the combined median

        // If the nums1.length + nums2.length is odd, the 2 function will return the same number
        // Else if nums1.length + nums2.length is even, the 2 function will return the left number and right number that make up a median
        return (getKth(nums1, 0, nums2, 0, l) + getKth(nums1, 0, nums2, 0, r)) / 2.0;
    }

    private double getKth(int[] nums1, int start1, int[] nums2, int start2, int k) {
        // This function finds the Kth element in nums1 + nums2

        // If nums1 is exhausted, return kth number in nums2
        if (start1 > nums1.length - 1) return nums2[start2 + k - 1];

        // If nums2 is exhausted, return kth number in nums1
        if (start2 > nums2.length - 1) return nums1[start1 + k - 1];

        // If k == 1, return the first number
        // Since nums1 and nums2 is sorted, the smaller one among the start point of nums1 and nums2 is the first one
        if (k == 1) return Math.min(nums1[start1], nums2[start2]);

        int mid1 = Integer.MAX_VALUE;
        int mid2 = Integer.MAX_VALUE;
        if (start1 + k / 2 - 1 < nums1.length) mid1 = nums1[start1 + k / 2 - 1];
        if (start2 + k / 2 - 1 < nums2.length) mid2 = nums2[start2 + k / 2 - 1];

        // Throw away half of the array from nums1 or nums2. And cut k in half
        if (mid1 < mid2) {
            return getKth(nums1, start1 + k / 2, nums2, start2, k - k / 2); //nums1.right + nums2
        } else {
            return getKth(nums1, start1, nums2, start2 + k / 2, k - k / 2); //nums1 + nums2.right
        }
    }
}
```

该题的难点在于`The overall run time complexity should be O(log (m+n)).`  
O(log (m+n))的时间复杂度递归可以达到。上面这种解法就是递归二分查找。
{: .notice--success }

如果抛开这个限制，这里有一种时间复杂度O(n)、空间复杂度O(1)的解法

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        final int m = nums1.length;
        final int n = nums2.length;
        int i = 0, j = 0, mid1, mid2, whichArray = 1, result = 0;

        mid1 = (m + n - 1) / 2;
        mid2 = (m + n) / 2;

        while (i < m || j < n) {
            if (i < m && j < n) {
                if (nums1[i] < nums2[j]) {
                    whichArray = 1;
                } else {
                    whichArray = 2;
                }
            } else if (i < m) {
                whichArray = 1;
            } else if (j < n) {
                whichArray = 2;
            }

            if (mid1 == i + j) {
                result = whichArray == 1 ? nums1[i] : nums2[j];
            }
            if (mid2 == i + j) {
                result += whichArray == 1 ? nums1[i] : nums2[j];
                return result / 2.0;
            }
            if (whichArray == 1) {
                i++;
            } else {
                j++;
            }
        }

        return 0.0;
    }
}
```

### 5. Longest Palindromic Substring

[String](/tags/#string){: .btn .btn--inverse } [Dynamic Programming](/tags/#dynamic-programming){: .btn .btn--inverse }

Given a string **s**, find the longest palindromic substring in **s**. You may assume that the maximum length of s is **1000**.  

**Example 1:**

Input: "babad"  
Output: "bab"  
Note: "aba" is also a valid answer.  
{: .notice }

**Example 2:**

Input: "cbbd"  
Output: "bb"
{: .notice }

****
```java
class Solution {
    public String longestPalindrome(String s) {
        if (s.length() < 2) {
            return s;
        }

        char[] ca = s.toCharArray();
        int rs = 0, re = 0;
        int max = 0;
        for(int i = 0; i < ca.length; i++) {
            if(isPalindrome(ca, i - max - 1, i)) {
                rs = i - max - 1; re = i;
                max += 2;
            } else if (isPalindrome(ca, i - max, i)) {
                rs = i - max; re = i;
                max += 1;
            }
        }
        return s.substring(rs, re + 1);
    }

    private boolean isPalindrome(char[] ca, int s, int e) {
        if(s < 0) return false;

        while(s < e) {
            if(ca[s++] != ca[e--]) return false;
        }
        return true;
    }
}
```

我们只需要以i为end点，以max为标准进行扩展，判断max+1或max+2长度的字符串是不是回数即可。
{: .notice--success }

### 6. ZigZag Conversion

[String](/tags/#string){: .btn .btn--inverse }

The string `"PAYPALISHIRING"` is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)

{% raw %}
P&emsp;&emsp;&emsp;A&emsp;&emsp;&emsp;H&emsp;&emsp;&emsp;N  
A&emsp;&nbsp;P&emsp;&nbsp;L&emsp;&nbsp;S&emsp;&nbsp;I&emsp;&nbsp;I&emsp;&nbsp;G  
Y&emsp;&emsp;&emsp;I&emsp;&emsp;&emsp;R
{% endraw %}
{: .notice }

And then read line by line: `"PAHNAPLSIIGYIR"`  

Write the code that will take a string and make this conversion given a number of rows:

```java
string convert(string s, int numRows);
```

**Example 1:**

Input: s = "PAYPALISHIRING", numRows = 3  
Output: "PAHNAPLSIIGYIR"  
{: .notice }

**Example 2:**

Input: s = "PAYPALISHIRING", numRows = 4  
Output: "PINALSIGYAHRPI"  
Explanation:  
P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N  
A&nbsp;&nbsp;&nbsp;L&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;G  
Y&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;H&nbsp;R  
P&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I  
{: .notice }

****
```java
class Solution {
    public String longestPalindrome(String s) {
        if (s.length() < 2) {
            return s;
        }

        char[] ca = s.toCharArray();
        int rs = 0, re = 0;
        int max = 0;
        for(int i = 0; i < ca.length; i++) {
            if(isPalindrome(ca, i - max - 1, i)) {
                rs = i - max - 1; re = i;
                max += 2;
            } else if (isPalindrome(ca, i - max, i)) {
                rs = i - max; re = i;
                max += 1;
            }
        }
        return s.substring(rs, re + 1);
    }

    private boolean isPalindrome(char[] ca, int s, int e) {
        if(s < 0) return false;

        while(s < e) {
            if(ca[s++] != ca[e--]) return false;
        }
        return true;
    }
}
```

我们只需要以i为end点，以max为标准进行扩展，判断max+1或max+2长度的字符串是不是回数即可。
{: .notice--success }
