---
title:  "View的事件体系(2)"
categories:
  - Android
  - Android SDK
tags:
  - 事件分发机制
  - 滑动冲突
toc: true
toc_label: "目录"
toc_icon: "heart"
---

## 4 View的事件分发机制
View的事件分发机制不只针对触摸事件，其他的事件（比如之前说到的Activity销毁重建时View的保存与恢复）也是类似的思想。都是Activity委托Window，Window委托DecorView，DecorView再来依次通知子元素。
### 4.1 触摸事件的传递规则
> 在View体系中，尤其需要注意一点：ViewGroup继承至View。

ViewGroup触摸事件的分发由三个重要的方法来共同完成：
1. public boolean dispatchTouchEvent(MotionEvent ev)
用来进行事件的分发。如果事件能够传递给当前View，此方法一定会被调用。返回true表示此事件被处理了。
2. public boolean onInterceptTouchEvent(MotionEvent ev)
用来判断是否拦截此事件。返回true表示拦截此事件。
3. public boolean onTouchEvent(MotionEvent event)
用来处理点击事件。返回true表示处理了事件。

下图表示ViewGroup的事件传递规则：

![ViewGroup的事件传递规则](http://upload-images.jianshu.io/upload_images/2525608-3e0fac551b8cf57c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

对于一个ViewGroup来说，点击事件产生后，其`dispatchTouchEvent`方法会被调用，如果其`onInterceptTouchEvent`返回true，表示ViewGroup要拦截该事件，其`onTouchEvent`就会被调用；否则，表示不拦截当前事件，点击事件就会传递给它的子元素，子元素的`dispatchTouchEvent`方法会被调用。如果最后点击事件传递到了View，由于View没有`onInterceptTouchEvent`方法，一旦有事件传递给它，其`onTouchEvent`就会被调用。
其关系可以用伪代码来表示：
```java
public boolean dispatchTouchEvent(MotionEvent ev) {
    boolean consume = false;
    if (onInterceptTouchEvent(ev)) {
        consume = onTouchEvent(ev);
    } else {
        consume = child.dispatchTouchEvent(ev);
    }

    return consume;
}
```

当一个点击事件产生后，它的传递过程如下：Activity -> Window -> 顶级View。顶级View再在View体系内部进行传递。

### 4.2 事件分发的源码解析
所有源码基于Android 7.1。
**1 Activity的事件分发过程**
当触摸事件传递到Activity时，也是从Activity的`dispatchTouchEvent`方法开始。
```java
    public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }
```
当触摸事件是ACTION_DOWN时，会回调`onUserInteraction`方法。`onUserInteraction`在Activity里面是一个空实现，会在按键事件、触摸事件、轨迹球事件分发到Activity时调用。
触摸事件的具体分发是由Activity内部的Window来完成的。Window是一个抽象类，其实现类是PhoneWindow（关于Window与WindowManager会在后续章节中讲解）。这点可以从Android 7.0以后的代码上直接看出来，具体在Activity类的[attach](http://androidxref.com/7.1.1_r6/xref/frameworks/base/core/java/android/app/Activity.java#6619)方法中`mWindow = new PhoneWindow(this, window);`。[更多关于Window可以查看](http://www.jianshu.com/p/1f0d194723f8)

下面接着看PhoneWindow的superDispatchTouchEvent方法：
```java
    @Override
    public boolean superDispatchTouchEvent(MotionEvent event) {
        return mDecor.superDispatchTouchEvent(event);
    }
```
PhoneWindow直接将事件委托给了DecorView处理，而DecorView是一个FrameLayout。
```java
** @hide */
public class DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks {
    ....
    public boolean superDispatchTouchEvent(MotionEvent event) {
        return super.dispatchTouchEvent(event);
    }
    ....
}
```
从这里开始，事件已经传递到了顶级View，顶级View一般都是ViewGroup。

因此，点击事件在Activity中的传递由Activity的`dispatchTouchEvent`方法开始，Activity会将事件交给Window处理，而Window又会转手交给DecorView处理。如果DecorView里面有View处理了触摸事件，那么Activity的`dispatchTouchEvent`会返回true；否则，如果没有View处理点击事件，那么Activity的`onTouchEvent`会被调用。

**2. 顶级View的事件分发过程**
在4.1节中我们说了ViewGroup的触摸事件传递规则。ViewGroup的事件分发机制主要体现在`dispatchTouchEvent`方法中。这个方法太长，也比较难看，我们分段说明。
这一段说明针对ACTION_DOWN进行的重置操作：
```java
// Handle an initial down.
if (actionMasked == MotionEvent.ACTION_DOWN) {
    // Throw away all previous state when starting a new touch gesture.
    // The framework may have dropped the up or cancel event for the previous gesture
    // due to an app switch, ANR, or some other state change.
    cancelAndClearTouchTargets(ev);
    resetTouchState();
}
```
当ACTION_DOWN事件来到时，ViewGroup会首先进行重置操作，清除触摸目标以及FLAG_DISALLOW_INTERCEPT标志位。


下面这一段说明的是否要拦截点击事件：
```java
 // Check for interception.
final boolean intercepted;
if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) {
    final boolean disallowIntercept = (mGroupFlags & FLAG_DISALLOW_INTERCEPT) != 0;
    if (!disallowIntercept) {
        intercepted = onInterceptTouchEvent(ev);
        ev.setAction(action); // restore action in case it was changed
    } else {
        intercepted = false;
    }
} else {
    // There are no touch targets and this action is not an initial down
    // so this view group continues to intercept touches.
    intercepted = true;
}
```
mFirstTouchTarget在ViewGroup的子元素成功处理事件时会被赋值指向子View。因此，**如果是ACTION_DOWN或者子元素成功处理时，ViewGroup才会判断是否要拦截当前事件**。反之，如果不是初始的ACTION_DOWN事件且没有触摸目标，ViewGroup会继续拦截触摸,，这样自己就会处理。
当然，FLAG_DISALLOW_INTERCEPT标志位是一个特殊情况。此标记位可以通过子View的`requestDisallowInterceptTouchEvent`设置当此标记位设置后，ViewGroup无法拦截除了ACTION_DOWN之外的事件。ACTION_DOWN事件无法拦截的原因是因为ViewGroup在分发事件时会重置此标记位（见第一段代码）。
在这两个判断条件中，ACTION_DOWN是为了处理手指按下的事件，这好理解；后者`mFirstTouchTarget != null`是为了能够使用内部拦截法处理滑动冲突，配合子元素的`requestDisallowInterceptTouchEvent`使ViewGroup每次分发触摸事件时都会调用`onInterceptTouchEvent `方法。

下面一段代码讲述的是ViewGroup不拦截之后，事件在子View中的分发
```java
if (!canceled && !intercepted) {

    // If the event is targeting accessiiblity focus we give it to the
    // view that has accessibility focus and if it does not handle it
    // we clear the flag and dispatch the event to all children as usual.
    // We are looking up the accessibility focused host to avoid keeping
    // state since these events are very rare.
    View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()
            ? findChildWithAccessibilityFocus() : null;

    if (actionMasked == MotionEvent.ACTION_DOWN
            || (split && actionMasked == MotionEvent.ACTION_POINTER_DOWN)
            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
        final int actionIndex = ev.getActionIndex(); // always 0 for down
        final int idBitsToAssign = split ? 1 << ev.getPointerId(actionIndex)
                : TouchTarget.ALL_POINTER_IDS;

        // Clean up earlier touch targets for this pointer id in case they
        // have become out of sync.
        removePointersFromTouchTargets(idBitsToAssign);

        final int childrenCount = mChildrenCount;
        if (newTouchTarget == null && childrenCount != 0) {
            final float x = ev.getX(actionIndex);
            final float y = ev.getY(actionIndex);
            // Find a child that can receive the event.
            // Scan children from front to back.
            final ArrayList<View> preorderedList = buildTouchDispatchChildList();
            final boolean customOrder = preorderedList == null
                    && isChildrenDrawingOrderEnabled();
            final View[] children = mChildren;
            for (int i = childrenCount - 1; i >= 0; i--) {
                final int childIndex = getAndVerifyPreorderedIndex(
                        childrenCount, i, customOrder);
                final View child = getAndVerifyPreorderedView(
                        preorderedList, children, childIndex);

                // If there is a view that has accessibility focus we want it
                // to get the event first and if not handled we will perform a
                // normal dispatch. We may do a double iteration but this is
                // safer given the timeframe.
                if (childWithAccessibilityFocus != null) {
                    if (childWithAccessibilityFocus != child) {
                        continue;
                    }
                    childWithAccessibilityFocus = null;
                    i = childrenCount - 1;
                }

                if (!canViewReceivePointerEvents(child)
                        || !isTransformedTouchPointInView(x, y, child, null)) {
                    ev.setTargetAccessibilityFocus(false);
                    continue;
                }

                newTouchTarget = getTouchTarget(child);
                if (newTouchTarget != null) {
                    // Child is already receiving touch within its bounds.
                    // Give it the new pointer in addition to the ones it is handling.
                    newTouchTarget.pointerIdBits |= idBitsToAssign;
                    break;
                }

                resetCancelNextUpFlag(child);
                if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                    // Child wants to receive touch within its bounds.
                    mLastTouchDownTime = ev.getDownTime();
                    if (preorderedList != null) {
                        // childIndex points into presorted list, find original index
                        for (int j = 0; j < childrenCount; j++) {
                            if (children[childIndex] == mChildren[j]) {
                                mLastTouchDownIndex = j;
                                break;
                            }
                        }
                    } else {
                        mLastTouchDownIndex = childIndex;
                    }
                    mLastTouchDownX = ev.getX();
                    mLastTouchDownY = ev.getY();
                    newTouchTarget = addTouchTarget(child, idBitsToAssign);
                    alreadyDispatchedToNewTouchTarget = true;
                    break;
                }

                // The accessibility focus didn't handle the event, so clear
                // the flag and do a normal dispatch to all children.
                ev.setTargetAccessibilityFocus(false);
            }
            if (preorderedList != null) preorderedList.clear();
        }

        if (newTouchTarget == null && mFirstTouchTarget != null) {
            // Did not find a child to receive the event.
            // Assign the pointer to the least recently added target.
            newTouchTarget = mFirstTouchTarget;
            while (newTouchTarget.next != null) {
                newTouchTarget = newTouchTarget.next;
            }
            newTouchTarget.pointerIdBits |= idBitsToAssign;
        }
    }
}
```
上面的代码配合注释也很清楚，首先从前往后遍历找到能够接受事件的View。是否能够接受事件由两个方法决定：子元素是否可见、是否在播放动画，点击事件的坐标是否落在子元素的区域内。如果某子元素满足这些条件，那么事件则会交给其处理。`dispatchTransformedTouchEvent`方法实际上调用的就是子元素的`dispatchTouchEvent`方法，这样触摸事件就交给子元素进行分发了。`dispatchTransformedTouchEvent`方法内部核心源码：
```java
        final boolean handled;
        ...
        if (child == null) {
            handled = super.dispatchTouchEvent(transformedEvent);
        } else {
            ...
            handled = child.dispatchTouchEvent(transformedEvent);
        }

        ...
        return handled;
```
当子元素的dispatchTouchEvent方法true，则mFirstTouchTarget会在`addTouchTarget(child, idBitsToAssign)`方法中完成赋值，然后跳出事件分发循环。

如果遍历所有子View都没有被合适地处理，此时ViewGroup就会自己处理点击事件。
```java
// Dispatch to touch targets.
if (mFirstTouchTarget == null) {
    // No touch targets so treat this as an ordinary view.
    handled = dispatchTransformedTouchEvent(ev, canceled, null,
        TouchTarget.ALL_POINTER_IDS);
}
```
在前面的代码中分析过`dispatchTransformedTouchEvent`方法，此处第三个参数传入null，显然会调用`super.dispatchTouchEvent(transformedEvent)`，即View的`dispatchTouchEvent`方法，此时点击事件会传递给View处理。

**3. View的事件处理过程**
View对点击事件的处理比较简单。因为View是叶子节点了，它没有子元素，无法向下传递事件，只能自己处理。

下面我们看看`dispatchTouchEvent`方法，同样View的`dispatchTouchEvent`方法也会判断到底要不要执行`onTouchEvent`：
```java
    public boolean dispatchTouchEvent(MotionEvent event) {
        ...
        boolean result = false;
        ...

        if (onFilterTouchEventForSecurity(event)) {
            ...
            //noinspection SimplifiableIfStatement
            ListenerInfo li = mListenerInfo;
            if (li != null && li.mOnTouchListener != null
                    && (mViewFlags & ENABLED_MASK) == ENABLED
                    && li.mOnTouchListener.onTouch(this, event)) {
                result = true;
            }

            if (!result && onTouchEvent(event)) {
                result = true;
            }
        }
        ...

        return result;
    }
```
View首先会判断有没有设置OnTouchListener，若有则会先执行OnTouchListener的`onTouch`方法。如果`onTouch`方法返回true，那么`onTouchEvent`不会被调用。因此OnTouchListener的优先级会比`onTouchEvent`要高。此外，若想`OnTouchListener`生效，View还要处于ENABLED状态。

接着看看`onTouchEvent`方法，该方法也有点长，但是非常好理解，我们分为几段来阅读。

1. 即使View处于DISABLED状态，只要其是可点击或者可长按，就能消耗事件。
```java
 if ((viewFlags & ENABLED_MASK) == DISABLED) {
    if (action == MotionEvent.ACTION_UP && (mPrivateFlags & PFLAG_PRESSED) != 0) {
        setPressed(false);
    }
    // A disabled view that is clickable still consumes the touch
    // events, it just doesn't respond to them.
    return (((viewFlags & CLICKABLE) == CLICKABLE
            || (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE)
            || (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
}
```

2. 如果有TouchDelegat，则调用TouchDelegat的onTouchEvent。若代理消耗了事件，则不再继续执行。
```java
if (mTouchDelegate != null) {
    if (mTouchDelegate.onTouchEvent(event)) {
        return true;
    }
}
```

3. 当View处于可点击或者可长按时，就会消耗事件，即`onTouchEvent`返回true。点击事件发生在`performClick`方法中。PerformClick是一个封装`performClick`在`run`方法的Runnable类。
```java
if (((viewFlags & CLICKABLE) == CLICKABLE ||
        (viewFlags & LONG_CLICKABLE) == LONG_CLICKABLE) ||
        (viewFlags & CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
    switch (action) {
        case MotionEvent.ACTION_UP:
                ...
                if (!mHasPerformedLongPress && !mIgnoreNextUpEvent) {
                    ...
                    if (!focusTaken) {
                        // Use a Runnable and post this rather than calling
                        // performClick directly. This lets other visual state
                        // of the view update before click actions start.
                        if (mPerformClick == null) {
                            mPerformClick = new PerformClick();
                        }
                        if (!post(mPerformClick)) {
                            performClick();
                        }
                    }
                }
            ...
            break;
        ...
    }

    return true;
}
```

4. 点击事件的执行过程：View首先会判断有没有设置OnClickListener，若有则会先执行OnClickListener的`onClick`方法，并返回true；否则返回false。
```java
    public boolean performClick() {
        final boolean result;
        final ListenerInfo li = mListenerInfo;
        if (li != null && li.mOnClickListener != null) {
            playSoundEffect(SoundEffectConstants.CLICK);
            li.mOnClickListener.onClick(this);
            result = true;
        } else {
            result = false;
        }

        ...
        return result;
    }
```

View的LONG_CLICKABLE属性默认为false；而CLICKABLE属性和具体的View有关，即可点击的View比如Button其属性为true，不可点击的比如TextView则为false。`setOnClickListener`以及`setOnLongClickListener`会将View的对应属性设为true。
```java
    public void setOnClickListener(@Nullable OnClickListener l) {
        if (!isClickable()) {
            setClickable(true);
        }
        getListenerInfo().mOnClickListener = l;
    }

    public void setOnLongClickListener(@Nullable OnLongClickListener l)  {
        if (!isLongClickable()) {
            setLongClickable(true);
        }
        getListenerInfo().mOnLongClickListener = l;
    }
```

**4. 事件传递规则的一些结论**
1. 一般情况下，一个事件序列只能被一个View拦截且消耗。一旦某个View开始拦截，那么这个事件序列都只能由它来处理，且其`onInterceptTouchEvent`方法不会在调用。*mFirstTouchTarget*
2. 某个View一旦开始处理事件，如果它不消耗ACTION_DOWN（既onTouchEvent方法返回了false），那么同一序列中其他事件不会交给它处理。*mFirstTouchTarget*
3. 如果View只消耗ACTION_DOWN，同时当前View可以持续受到后续事件。最后除了ACTION_DOWN之外的点击事件会传递给Activity处理。*mFirstTouchTarget收到了事件，但是其不消耗，也就是返回false。这样Activity就会调用`onTouchEvent`方法*
4. ViewGroup默认不拦截事件。
5. View没有`onInterceptTouchEvent`方法，事件一旦传递给View，其`onTouchEvent`方法就会调用
6. View的`onTouchEvent`默认会消耗事件，除非它是不可点击、不可长按的。View的longClickable默认为false，clickable要看View的类型。
7. View的enable属性不影响onTouchEvent的返回值。
8. onClick事件发生的前提是当前View必须是可点击的，并且要受到down和up事件。
9. 事件传递总是先传递给父布局，然后在传给子布局。子布局可以通过`requestDisallowInterceptTouchEvent`来干预父布局的事件分发，ACTION_DOWN除外。

## 5 View的滑动冲突处理
### 5.1 常见的滑动冲突场景
常见的滑动冲突场景可以分一下三类：
- 外部滑动方向与内部滑动方向不一致（左图）
- 外部滑动方向与内部滑动方向一致（右图）
- 上面两种情况的嵌套

![Screen Shot 2017-08-15 at 03.07.06.png](http://upload-images.jianshu.io/upload_images/2525608-3ac5d24759ac2798.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

场景1主要是ViewPager+Fragment，Fragment里面往往是一个ListView。但是ViewPager内部已经处理了这种滑动冲突，因此采用ViewPager时我们无需关系。但如果采用ScrollView就需要手动处理了。我们可以根据在水平方向和竖直方向移动的大小来判断用户往哪个方向移动。
> 提示：在ViewPager的一页中嵌套一个相同方向的ViewPager也无需处理滑动冲突。比如网易云的主界面。

场景2就比较复杂了，需要根据具体的逻辑来判断。一个典型的场景是电商应用商品详情页，滑到底部继续滑就可以从购买页面进入商品详情页面。

### 5.2 滑动冲突的解决方式
根据事件分发的原理，有两种处理方式：重写父容器`onInterceptTouchEvent`方法的**外部拦截法**，以及重写子元素`dispatchTouchEvent`和父容器`onInterceptTouchEvent`方法的**内部拦截法**。显然外部拦截法更方便。
#### 5.2.1 外部拦截法
外部拦截法的`onInterceptTouchEvent`方法如下所示：
```java
    int x, y, lastX, lastY;
    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        boolean intercepted = false;
        x = (int) ev.getX();
        y = (int) ev.getY();

        switch (ev.getAction()) {
            case MotionEvent.ACTION_DOWN:
            case MotionEvent.ACTION_UP:
                intercepted = false;
                break;

            case MotionEvent.ACTION_MOVE:
                if (shouldParentIntercept()) {
                    intercepted = true;
                } else {
                    intercepted = false;
                }
                break;
        }

        lastX = x;
        lastY = y;
        return intercepted;
    }

    private boolean shouldParentIntercept() {
        // TODO :
        return true;
    }
```
对于ACTION_DOWN，必须返回false。因此一旦返回true，父容器就会自己处理该点击事件，这将导致子View接收不到点击事件。
对于ACTION_MOVE，如果父布局需要拦截，返回true，否则false。
最后ACTION_UP，必须返回false。否则子元素无法出发onClick事件。

#### 5.2.2 内部拦截法
内部拦截法指父容器不拦截任何事件，所有事件都传递给子View。如果子View需要，则消耗掉。否则由父容器处理。这里需要`requestDisallowInterceptTouchEvent`配合。
子元素的`dispatchTouchEvent()`
```java
     int x, y, lastX, lastY;
    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        x = (int) ev.getX();
        y = (int) ev.getY();

        switch (ev.getAction()) {
            case MotionEvent.ACTION_DOWN:
                getParent().requestDisallowInterceptTouchEvent(true);
                break;

            case MotionEvent.ACTION_MOVE:
                if (shouldParentIntercept()) {
                    getParent().requestDisallowInterceptTouchEvent(false);
                }
                break;

            case MotionEvent.ACTION_UP:
                break;
        }

        lastX = x;
        lastY = y;

        return super.dispatchTouchEvent(ev);
    }

    private boolean shouldParentIntercept() {
        // TODO :
        return true;
    }
```

父容器的`onInterceptTouchEvent`
```java
    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        return ev.getAction() != MotionEvent.ACTION_DOWN;
    }
```
父布局不能拦截ACTION_DOWN，因为这样的话所有的事件无法传递到子View中。一个触摸事件由ACTION_DOWN开始，一旦有某个View处理了该事件，mFirstTouchTarget就被赋值了，后续事件全部会交给其处理。
