---
title:  "IPC机制(2)"
categories:
  - Android
  - Android SDK
tags:
  - IPC
  - Messenger
  - AIDL
  - ContentProvider
  - Socket
  - Binder连接池
toc: true
toc_label: "目录"
toc_icon: "heart"
---

## 1 Android中的IPC方式
Android中可以实现IPC方式的有很多，比如通过Intent附加extras传递信息，通过共享文件传递数据，还可以采用Binder方式来进行IPC。另外，ContentProvider天生就是支持PIC的，通过网络通信也是可以的，因此还可以采用`Socket`。上面的方式都可以进行IPC，但是使用方法和侧重点还是有很大的区别的。

IPC方式的优缺点以及使用场景


| 名称 | 优点 | 缺点 | 使用场景 |
| ----- | ------ | ------- | ------- |
| Bundle | 简单易用 | 只能传输Bundle支持的数据 | 四大组件之间的进程间通信 |
| 文件共享 | 简单易用 | 不适合高并发场景，且无法做到进程间的即时通信 | 无并发访问情况，交换简单的数据，实时性不高的场景 |
| AIDL | 功能强大，支持一对多并发通信，支持实时通信 | 使用稍复杂，需要处理好线程同步 | 一对多通信且有RPC需求 |
| Messenger | 功能一般，支持一对多串行通信，支持实时通信 | 不能很高的处理高并发情形，不支持RPC，数据通过Messenger进行传输，因此只能传输Bundle支持的数据类型 | 低并发的一对多即时通信，无RPC需求 |
| ContentProvider | 在数据源访问方面功能强大，支持一对多并发数据访问，可以通过Call方法扩展其他操作 | 可以理解为受约束的AIDL，主要提供对数据源CRUD操作 | 一对多的进程间的数据共享 |
| Socket | 功能强大，可以通过网络传输字节流，支持一对多并发实时通信 | 实现细节略嫌麻烦，不支持直接的RPC | 网络数据交换 |

### 1.1 使用Bundle
我们知道Intent的启动Activity、Service、Receiver都是通过构造`ComponentName`来实现的，我们可以使用`intent.setComponent(new ComponentName())`的方式来显示开启另一进程的组件，或者以隐式的方式开启。当然Bundle支持的数据类型有限。

### 1.2 使用文件共享
两个进程读写同一个文件来交换数据。在Window上，一个文件加了锁会导致其他进程无法访问该文件，但是在Linux上，对其进行并发读写是没有任何限制的，甚至可以并发写，尽管这很可能出问题。
文件共享适合在数据同步不高的进程间进行通信，并且要妥善处理好读写问题。

SharedPreferences也属于文件的一种，但是系统会在内存中持有一份SharedPreferences文件的缓存，因此在多进程模式下，系统对其进行的读写就不可靠，面对高并发的读写访问，SharedPreferences有很大几率会丢失数据。

### 1.3 使用Messenger
Messenger其底层实现是AIDL，可以在不同进程间传递Message对象，但它一次只能处理一个请求，因此不需要在服务端考虑因并发执行而产生的线程同步问题。实现一个客户端与服务端双向通信的Messenger需要以下步骤。

1. 服务端
服务端需要一个处理事务的Handler，并通过它创建Messenger对象，然后在onBind中返回Messenger对象底层的Binder即可。
若需要与客户端进行通信，可使用`msg.replyTo`方法获取客户端的Messenger对象，通过该对象发送Message，客户端即可接受到。
```java
public class MessengerService extends Service {
    public static final String TAG = "MessengerService";

    private static class MessengerHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            if (msg.what == 0x0001) {
                Log.d(TAG, "handleMessage: receive msg from Client : code = 0x0001, data = " +
                        msg.getData().getString("msg"));

                Messenger client = msg.replyTo;
                Message replyMsg = Message.obtain(null, 0x0002);
                Bundle data = new Bundle();
                data.putString("reply", "this is server");
                replyMsg.setData(data);
                try {
                    client.send(replyMsg);
                } catch (RemoteException e) {
                    e.printStackTrace();
                }
            }

            super.handleMessage(msg);
        }
    }

    private final Messenger mMessenger = new Messenger(new MessengerHandler());

    @Nullable
    @Override
    public IBinder onBind(Intent intent) {
        return mMessenger.getBinder();
    }
}
```

2. 客户端
客户端需要通过bind方式绑定服务端，并通过服务端返回的IBinder实例创建出Messenger对象，通过此对象发送Message可以和服务端进行通信。
为了能够响应服务端的回复，需要像服务端那样创建一个Messenger对象，并在发送消息给服务端时将`msg.replyTo`指定为该实例。
```java
public class MessengerActivity extends ActivityBase {
    public static final String TAG = "MessengerActivity";

    private Messenger mMessenger;
    private Messenger mReplyMessenger = new Messenger(new MessengerHandler());

    private static class MessengerHandler extends Handler {
        @Override
        public void handleMessage(Message msg) {
            if (msg.what == 0x0002) {
                Log.d(TAG, "handleMessage: receive msg from Server : code = 0x0002, data = " +
                        msg.getData().getString("reply"));
            }

            super.handleMessage(msg);
        }
    }
    private ServiceConnection mConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            mMessenger = new Messenger(service);
            Message msg = Message.obtain(null, 0x0001);
            Bundle data = new Bundle();
            data.putString("msg", "this is client");
            msg.setData(data);
            msg.replyTo = mReplyMessenger;
            try {
                mMessenger.send(msg);
            } catch (RemoteException e) {
                e.printStackTrace();
            }
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {

        }
    };

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_messenger);

        Intent intent = new Intent(this, MessengerService.class);
        bindService(intent, mConnection, Service.BIND_AUTO_CREATE);
    }

    @Override
    protected void onDestroy() {
        unbindService(mConnection);
        super.onDestroy();
    }
}

```

> D/MessengerService: handleMessage: receive msg from Client : code = 0x0001, data = this is client
D/MessengerActivity: handleMessage: receive msg from Server : code = 0x0002, data = this is server

**为了能够与服务端进行通信，需要在客户端以服务端返回的Messenger底层的Binder对象来构造一个Messenger，这样两端的Messenger实例相当于是同一个。
为了能够响应服务端，需要在客户端构建一个Messenger对象，并通过Message的relpyTo字段带到服务端，这样服务端可以通过这个Messenger来发送消息给客户端。**

### 1.4 使用AIDL
#### 1.4.1 定义AIDL接口
创建一个使用AIDL的绑定状态的Service，有以下几步
1. 创建.aidl文件
该文件定义了具有方法签名的程序接口。
2. 实现接口
Android SDK工具会基于.aidl文件自动生成一个Java实现的接口文件。接口有一个内部抽象类`Stub`，该类继承至Binder，实现了AIDL接口中的方法。我们必须继承`Stub`类，然后实现这些方法。
3. 将接口暴露给客户端
实现Service，重写`onBind`方法，返回`Stub`类的实例。
> **注意**: 在第一次释放后，AIDL接口的任何修改都必须能够向后兼容，这样能够避免破坏其他使用该Service的应用程序。也就是说，因为.aidl文件必须复制至其他应用为了能够使用我们的Service的接口，我们必须维护好原始接口。

**1. 创建.aidl文件**
AIDL支持以下数据类型：
- Java中所有基本数据类型(比如int, long, char, boolean等等)
- String和CharSequence
- List
List中所有的都必须能被AIDL支持。尽管方法使用的List接口，但另一方接收的实际具体类始终是ArrayList
- Map
Map中所有的都必须能被AIDL支持。尽管方法使用的Map接口，但另一方接收的实际具体类始终是HashMap
- Parcelable
所有实现了Parcelable接口的对象
- AIDL接口

**注意**：

1. 自定义的Parcelable对象和AIDL对象都必须显示import进来，不管是否在同一个包中。
2. 如果AIDL文件中用到了自定义的Parcelable对象，那么必须新建一个和它同名的AIDL文件，并在其中声明它为Parcelable类型。比如：
```java
package com.yorek.demo.aidl;
parcelable Book;
```
3. AIDL中除了基本数据类型外，其他类型的参数必须标上方向：`in`、`out`或者`inout`。基本类型默认都是`in`
4.  AIDL中只支持方法，不支持声明静态常量。



**2. 实现接口**
我们需要在Service中创建`Stub`类，然后实现AIDL的接口方法，如下所示
```java
private final IRemoteService.Stub mBinder = new IRemoteService.Stub() {
    public int getPid(){
        return Process.myPid();
    }
    public void basicTypes(int anInt, long aLong, boolean aBoolean,
        float aFloat, double aDouble, String aString) {
        // Does nothing
    }
};
```
实现接口时，有以下几条规则需要注意：
- AIDL是在服务端的Binder线程池中执行的，因此多个客户端同时访问时，需要处理好线程同步问题并保证线程安全。
- 默认情况下，RPC是同步的。如果service处理请求可能耗时的话，不要在Activity的主线程调用，这可能会导致ANR。客户端请求应该总是在子线程调用。
- 抛出的异常不会发送给调用者。

**3. 暴露接口给客户端**
在`onBind`方法中将上面步骤的mBinder方法返回。
客户端（比如Activity）在bindService成功时，客户端在`onServiceConnected`回调中接收IBinder实例，可以调用`YourServiceInterface.Stub.asInterface(service)`将IBinder实例转化成Service实例。比如
```java
IRemoteService mIRemoteService;
private ServiceConnection mConnection = new ServiceConnection() {
    // Called when the connection with the service is established
    public void onServiceConnected(ComponentName className, IBinder service) {
        // Following the example above for an AIDL interface,
        // this gets an instance of the IRemoteInterface, which we can use to call on the service
        mIRemoteService = IRemoteService.Stub.asInterface(service);
    }

    // Called when the connection with the service disconnects unexpectedly
    public void onServiceDisconnected(ComponentName className) {
        Log.e(TAG, "Service has unexpectedly disconnected");
        mIRemoteService = null;
    }
};
```

**AIDL权限验证的两种方式:**
1. 在`onBind`中验证，验证失败返回null。这样客户端无法绑定服务。
2. 在`Stub`中的`onTransact`方法中验证，验证失败返回false。这样服务端不会执行AIDL中的方法从而可以达到效果。

### 1.5 使用ContentProvider
和Messenger一样，ContentProvider底层实现同样也是Binder，但是使用过程比AIDL要简单的多。ContentProvider的具体类型可以查看
另一篇文章[Android四大组件(4)](http://www.jianshu.com/p/41696ae40906)

### 1.6 使用Socket
在服务端的Service里面使用`ServerSocket`来接收客户端的请求。在客户端使用`Socket`发送请求。通过I/O流发送、接收信息。这主要是Java知识了，不多做介绍。

另外在UDP协议中，Socket对应的是`DatagramPackage`以及`DatagramSocket`。

## 2 Binder连接池
Binder连接池不是Binder线程池。Binder连接池的作用是将各个业务模块的Binder统一转发到Service中，这样可以避免Service的重复创建。
随着AIDL数量的增加，Service的数量不能无限增加。

创建一个Binder连接池有以下三步
1. 为Binder连接池新建IBinderPool.aidl
```java
// IBinderPool.aidl
package yorek.demoandtest.ipc.binderpool;

interface IBinderPool {
    IBinder queryBinder(int binderCode);
}
```

2. 为Binder连接池创建远程Service并实现IBinderPool(`IBinderPool.Stub`可以放到Binder连接池具体实现中，因此此处可以直接创建连接池中的Stub类)。当Binder连接池连接上远程服务时，会根据不同的binderCode返回不同的Binder对象，通过这个BInder对象所执行的操作全部发生在远程Service中。
```java
public class BinderPoolService extends Service {
    public static final String TAG = "BinderPoolService";

    private Binder mBinderPool = new BinderPool.BinderPoolImpl();

    @Override
    public IBinder onBind(Intent intent) {
        Log.d(TAG, "onBind: ");
        return mBinderPool;
    }
}
```

3. 实现Binder连接池
```java
public class BinderPool {
    public static final String TAG = "BinderPool";

    public static final int BINDER_NONE = -1;
    public static final int BINDER_JOB_ONE = 0;
    public static final int BINDER_JOB_TWO = 1;

    private Context mContext;
    private IBinderPool mBinderPool;
    private static volatile BinderPool sInstance;
    private CountDownLatch mCountDownLatch;

    private ServiceConnection mBinderPoolConnection = new ServiceConnection() {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            mBinderPool = IBinderPool.Stub.asInterface(service);
            try {
                mBinderPool.asBinder().linkToDeath(mBindPoolDeathRecipient, 0);
            } catch (RemoteException e) {
                e.printStackTrace();
            }

            mCountDownLatch.countDown();
        }

        @Override
        public void onServiceDisconnected(ComponentName name) {}
    };
    private IBinder.DeathRecipient mBindPoolDeathRecipient = new IBinder.DeathRecipient() {
        @Override
        public void binderDied() {
            Log.w(TAG, "[binderDied] binder died.");
            mBinderPool.asBinder().unlinkToDeath(mBindPoolDeathRecipient, 0);
            mBinderPool = null;

            connectBinderPoolService();
        }
    };

    private BinderPool(Context context) {
        mContext = context.getApplicationContext();
        connectBinderPoolService();
    }

    public static BinderPool getInstance(Context context) {
        if (sInstance == null) {
            synchronized (BinderPool.class) {
                if (sInstance == null) {
                    sInstance = new BinderPool(context);
                }
            }
        }

        return sInstance;
    }

    private synchronized void connectBinderPoolService() {
        mCountDownLatch = new CountDownLatch(1);
        Intent service = new Intent(mContext, BinderPoolService.class);
        mContext.bindService(service, mBinderPoolConnection, Context.BIND_AUTO_CREATE);

        try {
            mCountDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public IBinder queryBinder(int binderCode) {
        IBinder binder = null;
        try {
            if (mBinderPool != null) {
                binder = mBinderPool.queryBinder(binderCode);
            }
        } catch (RemoteException e) {
            e.printStackTrace();
        }

        return binder;
    }

    public static class BinderPoolImpl extends IBinderPool.Stub {
        @Override
        public IBinder queryBinder(int binderCode) throws RemoteException {
            IBinder binder = null;

            switch (binderCode) {
                case BINDER_JOB_ONE:
                    // binder = new SecurityCenterImpl();
                    break;

                case BINDER_JOB_TWO:
                    // binder = new ComputeImpl();
                    break;

                default:
            }

            return binder;
        }
    }
}
```

具体使用:
```java
private void doWork() {
        BinderPool binderPool = BinderPool.getInstance(this);
        IBinder jobOneBinder = binderPool.queryBinder(BinderPool.BINDER_JOB_ONE);
        //ISecurityCenter mSecurityCenterImpl =
        //        (ISecurityCenter) SecurityCenterImpl.asInterface(jobOneBinder);
    }
```
在获取Binder连接池实例时，如果是第一次获取会执行`connectBinderPoolService`方法绑定到远程Service中，远程Service中运行着`BinderPool.Stub`实例。
注意，使用连接池时需要在额外的线程中使用，这是因为在Binder连接池中，我们通过`CountDownLatch`将`bindService`这一异步操作转换成了同步操作，这就意味着它可能是耗时的，加上**Binder方法的调用过程也可能是耗时的**，因此不建议放到主线程中。
