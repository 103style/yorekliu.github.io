---
title:  "View的事件体系(1)"
categories:
  - Android
  - Android SDK
tags:
  - View
  - VelocityTracker
  - GestureDetector
  - Scroller
toc: true
toc_label: "目录"
toc_icon: "heart"
---

本章的主要内容有：
- View的基础知识
- View的滑动、弹性滑动
- View的事件分发机制
- View的滑动冲突处理

## 1 View的基础知识
本节包括View的位置参数、MotionEvent、VelocityTracker、GestureDetector以及Scroller。

### 1.1 View的位置参数
View的位置由四个顶点来决定：top、left、right、bottom，这些都是相对于View的父容器来说的，因此是一种相对坐标。
从Android 3.0以来，View新增了几个参数坐标：x、y、translationX、translationY。x、y是View的左上角的坐标，translationX、translationY是View左上角相对于父容器的偏移量。这也是一种相对坐标。
这几个坐标的换算关系如下：
x = left + translationX
y = top + translationY

x、y这两个坐标参数都是虚拟的，其getter和setter是通过left、top、translationX和translationY四个参数转化而来的。
```java
    /**
     * The visual x position of this view, in pixels. This is equivalent to the
     * {@link #setTranslationX(float) translationX} property plus the current
     * {@link #getLeft() left} property.
     *
     * @return The visual x position of this view, in pixels.
     */
    @ViewDebug.ExportedProperty(category = "drawing")
    public float getX() {
        return mLeft + getTranslationX();
    }

    /**
     * Sets the visual x position of this view, in pixels. This is equivalent to setting the
     * {@link #setTranslationX(float) translationX} property to be the difference between
     * the x value passed in and the current {@link #getLeft() left} property.
     *
     * @param x The visual x position of this view, in pixels.
     */
    public void setX(float x) {
        setTranslationX(x - mLeft);
    }
```
> **注意**：在View的平移过程中，发生改变的是x、y、translationX、translationY这几个参数。top和left是表示原始左上角的位置信息，其值不会发生改变。

### 1.2 MotionEvent
1. MotionEvent
MotionEvent典型的三个事件：ACTION_DOWN、ACTION_MOVE、ACTION_UP
两组方法：`getX/getY`和`getRawX/getRawY`。前者获取View左上角的x/y值，后者获取的是相对于屏幕左上角的x/y值。

![View的四个顶点以及MotionEvent的x、y、rawX、rawY](http://upload-images.jianshu.io/upload_images/2525608-5481ec96b0a9f1f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

2. 触摸事件的一些常量
这些常量定义在`frameworks/base/core/res/res/values/config.xml `文件中。
```xml
    < !-- Base "touch slop" value used by ViewConfiguration as a movement threshold where scrolling should begin. -->
    <dimen name="config_viewConfigurationTouchSlop">8dp</dimen>

    < !-- Minimum velocity to initiate a fling, as measured in dips per second. -->
    <dimen name="config_viewMinFlingVelocity">50dp</dimen>

    < !-- Maximum velocity to initiate a fling, as measured in dips per second. -->
    <dimen name="config_viewMaxFlingVelocity">8000dp</dimen>
```
除了触摸事件，还有其他的信息也定义在其中，比如启用短信强制7bit编码的config_sms_force_7bit_encoding等。
```xml
<bool name="config_sms_force_7bit_encoding">false</bool>
```

TouchSlop是系统能够识别出的被认为是滑动的最小距离(一般是8dp)。
被识别为Fling的最大、最小速度也可以获取。
可以通过如下方式获取这些常量：
```java
ViewConfiguration.get(this).getScaledTouchSlop();
ViewConfiguration.get(this).getScaledMinimumFlingVelocity();
ViewConfiguration.get(this).getScaledMaximumFlingVelocity();
```
### 1.3 VelocityTracker、GestureDetector和Scroller
#### 1.3.1 VelocityTracker
VelocityTracker可以用来追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。
1. 首先在View的onTouchEvent方法中追踪当前点击事件的速度
```java
VelocityTracker velocityTracker = VelocityTracker.obtain();
velocityTracker.addMovement(event);
```
2. 在我们想知道当前的滑动速度时：
```java
velocityTracker.computeCurrentVelocity(1000);

int xV = (int) velocityTracker.getXVelocity();
int xY = (int) velocityTracker.getYVelocity();
```
这里的速度指的是单位时间内手指滑过的像素数。水平从左往右滑动，水平速度为正；反之，为负。
3. 在不需要时，需要释放掉资源
```java
velocityTracker.clear();
velocityTracker.recycle();
```

#### 1.3.2 GestureDetector
手势检测器，用来辅助检测用户的单击、滑动、长按、双击等行为。
1. 创建一个GestureDetector对象并实现OnGestureListener接口，根据需要还可以选择实现OnDoubleTapListener接口从而监听双击行为：
```java
GestureDetector mGestureDetector = new GestureDetector(this);
// 解决长按屏幕无法拖动的现象
mGestureDetector.setIsLongpressEnabled(false);
```
2. 接管目标View的没TouchEvent方法，在待监听View的onTouchEvent方法中加如下实现：
```java
boolean consume = mGestureDetector.onTouchEvent(event);
return consume;
```

OnGestureListener接口、OnDoubleTapListener接口方法有很多：
**OnGestureListener接口**

| 方法名 | 描述 |
| -------- | -------- |
| onDown | 手指触摸屏幕的一瞬间，由ACTION_DOWN触发 |
| onShowPress | 手指触摸屏幕，没有移动也没有松开，由ACTION_DOWN触发（注意其强调的状态） |
| onSingleTapUp | 手指点击后松开，由ACTION_UP触发 |
| onScroll | 手指滑动，由一个ACTION_DOWN，多个ACTION_MOVE触发 |
| onLongPress | 长按事件 |
| onFling | 快速滑动，由一个完整的事件序列触发 |

**OnDoubleTapListener接口**

| 方法名 | 描述 |
| -------- | -------- |
| onDoubleTap | 双击事件，不能和onSingleTapConfirmed共存 |
| onSingleTapConfirmed | 严格的单击行为 |
| onDoubleTapEvent | 发生了双击行为，在双击期间，down move up都会触发此回调 |

#### 1.3.3 Scroller
Scroller课用于实现View的弹性滑动。Scroller本身无法让View弹性滑动，它需要和View的`computeScroll`方法配合使用才能共同完成这个功能。
```
 java private Scroller mScroller = new Scroller(context);
 ...
 public void zoomIn() {
     // Revert any animation currently in progress
     mScroller.forceFinished(true);
     // Start scrolling by providing a starting point and
     // the distance to travel
     mScroller.startScroll(0, 0, 100, 0);
     // Invalidate to request a redraw
     invalidate();
 }

 @Override
 public void computeScroller() {
     if (mScroller.computeScrollOffset()) {
         // Get current x and y positions
         int currX = mScroller.getCurrX();
         int currY = mScroller.getCurrY();

         scrollTo(currX, currY);
         postInvalidate();
     }
 }
```

## 2 View的滑动
实现View的滑动有很多种方法，一般有五种方法：
1. layout()
layout()方法会调用onLayout()来设置显示的位置，传入left、top、right、bottom四个参数即可。
2. offsetLeftAndRight()/offsetTopAndBottom()
此方法和layout()差不多，`offsetLeftAndRight()`传入x轴方向的偏移，`offsetTopAndBottom()`传入y轴方向的偏移。
3. LayoutParams

```java
ViewGroup.MarginLayoutParams layoutParams = (ViewGroup.MarginLayoutParams) view.getLayoutParams();
layoutParams.width = 100;
layoutParams.leftMargin = 200;
layoutParams.rightMargin = 200;
view.setLayoutParams(layoutParams);
//或者view.requestLayout();
```
4. 动画
通过动画改变，主要是操作View的`translationX`和`translationY`两个属性
5. scrollTo()/scrollBy()
`scrollBy`调用了`scrollTo`，前者是相对于当前位置的相对滑动，后者是绝对滑动。
> **注意**：使用scrollTo()/scrollBy()来实现View的滑动，只能将View的内容进行移动，并不能移动内容本身。因此mScrollX和mScrollY的值是平常理解的值得相反数，也就是说：如果想让内容从左往右滑动，那么mScrollX为负值；从上往下，mScrollY为负值。

## 3 弹性滑动
弹性滑动的思想：化整为零，将一次大的滑动分为若干次小的滑动，并在一段时间内完成。比如Scroller、动画、使用Handler的postDelayed或者Thread的sleep等。
> 注意：此处说的滑动是指View内容的滑动，而不是View本身。
### 3.1 使用Scroller实现弹性滑动
在1.3.3节中我们说了Scroller的使用方法，Scroller的使用就是两个方法的调用`startScroll`以及`computeScrollOffset`。
先来看一下`startScroll`方法：
```java
    public void startScroll(int startX, int startY, int dx, int dy, int duration) {
        mMode = SCROLL_MODE;
        mFinished = false;
        mDuration = duration;
        mStartTime = AnimationUtils.currentAnimationTimeMillis();
        mStartX = startX;
        mStartY = startY;
        mFinalX = startX + dx;
        mFinalY = startY + dy;
        mDeltaX = dx;
        mDeltaY = dy;
        mDurationReciprocal = 1.0f / (float) mDuration;
    }
```
`startScroll`方法内部什么也没有做，只是保存了传递进来的几个参数，然后根据这些参数初始化相关的参数。在这里中mFinished初始化为false，mMode为SCROLL_MODE。
然后看下`computeScrollOffset`方法，由于mMode初始化为SCROLL_MODE，所以我们只看这部分的代码：
```java
    public boolean computeScrollOffset() {
        if (mFinished) {
            return false;
        }

        int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);

        if (timePassed < mDuration) {
            switch (mMode) {
            case SCROLL_MODE:
                final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);
                mCurrX = mStartX + Math.round(x * mDeltaX);
                mCurrY = mStartY + Math.round(x * mDeltaY);
                break;
            case FLING_MODE:
                 ......

                break;
            }
        }
        else {
            mCurrX = mFinalX;
            mCurrY = mFinalY;
            mFinished = true;
        }
        return true;
    }
```
`computeScrollOffset`返回true表示正在计算，返回false表示已经计算完成(滑动随之完成)。在此方法中我们可以看到，此方法的作用就是根据时间流逝的百分比来计算出scrollX、scrollY改变的百分比，最后在计算出当前的值(mCurrX、mCurrY)，这类似于动画中Interpolator的概念。
Scroller真正让View产生弹性滑动的原因是`startScroll`下面的`invalidate()`方法。`invalidate()`会导致View重绘，重绘时会调用`draw`方法，`draw`又会调用`computeScrollOffset`方法。在`computeScrollOffset`方法中会滑动一小段距离，然后又调用`postInvalidate`进行第二次重绘，直到整个过程结束。

### 3.2 使用动画
使用动画来实现弹性滑动很简单，不做过多的描述。但其本身的原理也是化整为零，涉及到的原理有插值器Interpolator、估值器TypeEvaluator。
插值器的作用是根据时间流逝的百分比来确定动画执行过程的百分比。
估值器的作用是根据动画过程执行的百分比来确定当前的位置。
上面Scroller的`computeScrollOffset()`方法实现的功能就类似与插值器和估值器的功能。
关于动画的详细内容会在[后续的章节](http://www.jianshu.com/p/4b55ef5a99e0)中讲解。

### 3.3 使用延时策略
延时策略实现弹性滑动的核心思想是通过发送一系列延时消息从而达到一种渐进式的效果。具体来说可以使用Handler或者View的postDelayed，也可以使用线程的sleep方法。实现也比较简单，不过多描述。
