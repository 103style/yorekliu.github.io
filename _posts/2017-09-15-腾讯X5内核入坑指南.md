---
categories:
  - Android
tags:
  - TBS
  - X5
toc: true
toc_label: "目录"
toc_icon: "heart"
---

接入X5内核而不是原生的WebView的主要原因是X5内核兼容性好（待考证）。我司的这个产品只是使用WebView通过JS与客户端交互，并没有使用其他的诸如视频等等功能。但就算如此，在某些机型上仍然会崩溃。

### 1. 接入过程
接入过程很简单，下面简单的记录下接入的流程。我司现在接入的是Android SDK（3.3完整版）。

**1. 下载SDK以及DEMO**
此步骤我们需要拿到两个东西：一个jar文件、一个so文件。
下载位置在https://x5.tencent.com/tbs/sdk.html
根据情况下载SDK以及SDK接入示例-Android Studio。
SDK里面我们需要用到的是tbs_sdk_thirdapp_v3.3.0.1045_....jar 这个包。这个包我们需要放到app/libs文件夹中。
![jar包放置位置](http://upload-images.jianshu.io/upload_images/2525608-dd6403d4d327a917.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
然后DEMO里面我们需要提取一个so库文件，位置在X5WebDemo/src/main/jniLibs/armeabi/liblbs.so，提取后放到我们自己项目的对应位置。
![so库放置位置](http://upload-images.jianshu.io/upload_images/2525608-bd36e743cb27eaa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


**2. 开始接入SDK**
SDK的接入文档在：https://x5.tencent.com/tbs/guide/sdkInit.html
SDK的接入可以查看官方文档，这里简单的记录一下接入过程
1. 在自己的Application类中预初始化X5内核
初始化操作可以通过` QbSdk.initX5Environment`方法来完成，如下。
```java
public class MyApp extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        ......
        QbSdk.initX5Environment(this, new QbSdk.PreInitCallback() {
            @Override
            public void onCoreInitFinished() {
                // X5内核加载完成后回调
                LogUtils.i("onCoreInitFinished -----------");
            }

            @Override
            public void onViewInitFinished(boolean b) {
                // 传入参数b为true表示加载X5成功，false表示加载失败
                LogUtils.i("onViewInitFinished " + b + " -----------");
            }
        }); // pre-init X5
    }
}
```
这个函数内是异步执行所以不会阻塞 App 主线程，这个函数内是轻量级执行所以对 App 启动性能没有影响，当 App 后续创建 webview 时就可以首次加载 x5 内核了

2. AndroidManifest.xml里加入权限声明
```xml
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
<uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
<uses-permission android:name="android.permission.INTERNET" />
<uses-permission android:name="android.permission.READ_PHONE_STATE" />
```

3. 将原本webkit相关的类全部替换成X5内核中的
这个步骤包括xml代码以及Java代码里面的。具体的替换表如下：

| 系统内核 | SDK内核|
| :---------- | :------------ |
| android.webkit.ConsoleMessage | com.tencent.smtt.export.external.interfaces.ConsoleMessage |
| android.webkit.CacheManager | com.tencent.smtt.sdk.CacheManager(deprecated) |
| android.webkit.CookieManager | com.tencent.smtt.sdk.CookieManager |
| android.webkit.CookieSyncManager | com.tencent.smtt.sdk.CookieSyncManager |
| android.webkit.CustomViewCallback | com.tencent.smtt.export.external.interfaces.IX5WebChromeClient.CustomViewCallback |
| android.webkit.DownloadListener | com.tencent.smtt.sdk.DownloadListener |
| android.webkit.GeolocationPermissions | com.tencent.smtt.export.external.interfaces.GeolocationPermissionsCallback |
| android.webkit.HttpAuthHandler | com.tencent.smtt.export.external.interfaces.HttpAuthHandler |
| android.webkit.JsPromptResult | com.tencent.smtt.export.external.interfaces.JsPromptResult |
| android.webkit.JsResult | com.tencent.smtt.export.external.interfaces.JsResult |
| android.webkit.SslErrorHandler | com.tencent.smtt.export.external.interfaces.SslErrorHandler |
|android.webkit.ValueCallback | com.tencent.smtt.sdk.ValueCallback |
| android.webkit.WebBackForwardList | com.tencent.smtt.sdk.WebBackForwardList |
|android.webkit.WebChromeClient | com.tencent.smtt.sdk.WebChromeClient |
|android.webkit.WebHistoryItem | com.tencent.smtt.sdk.WebHistoryItem |
| android.webkit.WebIconDatabase | com.tencent.smtt.sdk.WebIconDatabase |
| android.webkit.WebResourceResponse | com.tencent.smtt.export.external.interfaces.WebResourceResponse |
|android.webkit.WebSettings | com.tencent.smtt.sdk.WebSettings |
|android.webkit.WebSettings.LayoutAlgorithm | com.tencent.smtt.sdk.WebSettings.LayoutAlgorithm |
| android.webkit.WebStorage | com.tencent.smtt.sdk.WebStorage |
|android.webkit.WebView | com.tencent.smtt.sdk.WebView |
|android.webkit.WebViewClient | com.tencent.smtt.sdk.WebViewClient |

> 为了确保替换的完整，可以使用脚本[checkqbsdk.sh](http://res.imtt.qq.com/TES/checkqbsdk.zip)进行扫描，windows上使用[TBSSdk接入扫描工具.exe](http://res.imtt.qq.com/TES/TBSSdk_windows.zip)进行扫描。脚本放在所有源码的顶级目录下运行即可。后续的版本发布前尽量都运行一遍扫描，以免上次扫描后新提交的代码有未替换的情况发生。
替换不完全时，可能发生的问题是关于cookie的身份错误、类转换时的crash等。cookie问题产生的原理是:一段代码把cookie塞给了系统内核，另外一段代码尝试从x5的内核里读取cookie就失败了。类转换的错误产生的原理是：比如xml里指定的是系统的webview，java的代码里把它当作x5的webview使用。

至此，X5内核的WebView已经可以跑起来了。下面还有一些踩过的坑。

### 2. 采坑指南
**1. 加载X5内核不成功的问题**
因为我司产品中接入了其他第三方so，这些so文件不仅仅提供了armeabi这个so，还提供了其他的。所以app的gradle中进行了如下配置：
```java
ndk {
    abiFilters 'armeabi-v7a', 'armeabi-v8a', 'arm64-v8a'
}
```
所以导致x5加载不成功，可以参考：https://x5.tencent.com/tbs/technical.html#/detail/sdk/1/34cf1488-7dc2-41ca-a77f-0014112bcab7

按照其说法，我们只能这么配置：
```java
ndk {
    abiFilters 'armeabi'
}
```
这样其他第三方so也要使用armeabi里面的so。

**2. Cookie问题**
> 调整cookie的使用：
com.tencent.smtt.sdk.CookieManager和com.tencent.smtt.sdk.CookieSyncManager的相关接口的调用，在接入SDK后，需要放到创建X5的WebView之后（也就是X5内核加载完成）进行；否则，cookie的相关操作只能影响系统内核。

在这个产品中所有的业务操作（WebView在这部分使用）都需要登录，登录是一个native界面。登录成功后需要保存Cookie。但是X5必须在WebView创建也就是`new`之后才能使用X5里面的Cookie。所以这部分的Cookie不能通过CookieManager了，我们采用的是SharedPreference来保存。*如果有更好的方式通过CookieManager的方式，欢迎交流*。

**3. 屏蔽长按事件**
https://x5.tencent.com/guide?id=2013

tbs1.x：使用webview.getView().setLongClickListener()设置X5webview的长按监听，在listener中重写onLongClick方法，返回true就能禁止掉X5 webview的长按功能。

tbs2.x：在IX5WebViewClientExtension的实现类的onShowLongClickPopupMenu方法中直接return true；
