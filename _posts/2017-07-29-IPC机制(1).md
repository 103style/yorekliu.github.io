---
title:  "IPC机制(1)——IPC基础概念"
excerpt: "Android中的多进程模式、Serializable接口、Parcelable接口以及Binder的Java层工作原理"
header:
  teaser: /assets/images/fragment_lifecycle.png
  overlay_image: /assets/images/fragment_lifecycle.png
  overlay_filter: 0.5
  caption: "Photo credit: [**Google**](https://developer.android.com/guide/components/fragments.html)"
  cta_url: "https://developer.android.com/guide/components/fragments.html"
categories:
  - Android
  - Android SDK
tags:
  - IPC
  - process
  - Serializable
  - Parcelable
  - Binder
toc: true
toc_label: "目录"
toc_icon: "heart"
---

## 1 Android IPC简介
IPC全称为interprocess communication，中文为进程间通信，是指两个进程间进行数据交换的过程。

进程(process)和线程(thread)是两个不同的概念。进程一般指一个一个执行单元，是程序运行的实例，在移动设备上指一个应用；而线程是CPU调度和分派的最小单位。一个进程中可以有多个线程，两者是包含与被包含关系。

**每一个Android应用程序都在它自己的进程中运行，都拥有一个独立的 Dalvik 虚拟机实例。而每一个 DVM 都是在Linux中的一个进程，所以说可以认为是同一个概念。**

任何一个操作系统都有相应的IPC机制，Linux上面可以通过命名管道、共享内存、信号量等来进行IPC。而在Android中，最有特色的就是Binder，通过Binder可以轻松进行IPC操作。

## 2 Android中的多进程模式
在Android中我们可以通过指定四大组件的`android:process`属性来轻易的开启多进程，除此之外，没有其他办法达到目的。当然我们还可以通过JNI在native层去fork新的进程，但这不常规。

process名称可以通过":"来简写，这样开启的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中；而进程名不以":"开头的进程属于全局进程，其他应用可以通过shareUID方式和它跑在同一进程中。

Android为每一个应用分配了一个唯一的UID，具有相同UID的应用才能共享数据。两个应用通过ShareUID跑在同一进程中是有要求的，需要两者有同样的ShareUID并且签名相同。**UID相同，不管是否在同一进程中，它们可以互相访问对方的私有数据，包括data目录、组件信息等——一个程序的两个进程。如果在同一进程中，它们还能共享内存数据——就相当于一个程序。**

由于每个进程都有独立的虚拟机，不同的虚拟机在内存上对应不同的地址空间。因此它们之间通过内存来共享数据都会共享失败。一般来说，使用多进程会导致以下问题：
- 静态成员和单例模式完全失效
- 线程同步机制完全失效
- SharedPreferences的可靠性下降
- Application会多次创建 (*统计app启动次数时，需要注意此坑。Application也能被第三方Push SDK唤起*)

## 3 IPC基础概念介绍
本节主要包含三个方面的内容：Serializable接口、Parcelable接口以及Binder。

### 3.1 Serializable接口
Serializable接口是Java提供的一个序列化接口，它是一个空接口，使用时只需要实现Serializable并声明一个serialVersionUID就可以，无需override任何方法。
```java
private static final long serialVersionUID = 32163781263816L;
```
可以将实现了Serializable接口的对象序列化到文件中或者从文件中反序列化，操作非常简单。
```java
// 序列化过程
User user = new User();
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("cache.txt"));
oos.writeObject(user);
oos.close();

// 反序列化过程
ObjectInputStream ins = new ObjectInputStream(new FileInputStream("cache.txt"));
User newUser = (user) ins.readObject();
ins.close();
```
实际上，甚至serialVersionUID常量都不是必须的，如果我们不声明这个常量，序列化会正常进行，但是会影响反序列化。

**serialVersionUID的作用**  
serialVersionUID是用来辅助序列化和反序列化过程的，只有序列化后的数据中的serialVersionUID和当前类的serialVersionUID相同时才能正常的反序列化。当两者不相同时，会报`InvalidClassException`错误。

因此我们应该指定serialVersionUID的值为一个常量，比如1L，这样当类的结构发生变化(比如曾删某些成员变量)时，我们仍然能够最大化的避免反序列化的失败，能够最大限度的恢复数据。

如果类结构发生了非常规性变化，比如修改了类名，修改了成员变量的类型，此时尽管serialVersionUID验证通过了，但是反序列化还是会失败。

另外，默认的序列化过程是可以改变的，只需要重写`writeObject`和`writeObject`即可。

### 3.2 Parcelable接口
Parcelable接口也是一种Android中的序列化接口，性能比Serializable要好，性能要高，但是需要实现额外的方法。

Parcelable主要用在内存序列化上，但是通过Parcelable可以将对象序列化到存储设备中或将对象序列化后通过网络传输也都是可以的，这是过程会稍显复杂，因此这种情况下建议使用Serializable。
实现`Parcelable`接口需要override`describeContents()`和`writeToParcel()`两个方法，以及一个`Parcelable.Creator<T>`的内部类。
```java
 public class MyParcelable implements Parcelable {
     private int mData;
     private Book book;

     public int describeContents() {
         return 0;
     }

     public void writeToParcel(Parcel out, int flags) {
         out.writeInt(mData);
         out.writeParcelable(book, 0);
     }

     public static final Parcelable.Creator<MyParcelable> CREATOR
             = new Parcelable.Creator<MyParcelable>() {
         public MyParcelable createFromParcel(Parcel in) {
             return new MyParcelable(in);
         }

         public MyParcelable[] newArray(int size) {
             return new MyParcelable[size];
         }
     };

     private MyParcelable(Parcel in) {
         mData = in.readInt();
         book = in.readParcelable(Thread.currentThread().getContextClassLoader());
     }
 }
```
`describeContents`方法一般返回0，仅当当前对象中存在文件描述符时，才返回1。另外，由于Book是一个Parcelable对象，因此反序列化过程需要传递当前线程的上下文加载器，否则会报无法找到类的错误。

`writeToParcel`，其中flags有两种值：0和1。当为1时，当前对象需要作为返回值返回，不能立即释放资源，几乎所有的情况都返回0。

> Android Studio可以下载**Android Parcelable code generator**插件辅助完成序列化接口的书写。

### 3.3 Binder
在Android开发中，Binder是Android中的一个类，它实现了IBinder接口。它是Android中一种跨进程通讯方式。从framework角度来说，Binder是ServiceManager连接各种Manager(比如ActivityManager、WindowManager等)和相应ManagerService的桥梁；从Application的角度来讲，Binder是Client与Server进行通信的媒介。

Binder在Android中主要用于Service中，包括AIDL和Messenger。

关于AIDL，我们可以在菜单中选择创建一个aidl文件，文件会生成在
`demoandtest/app/src/main/aidl/yorek/demoandtest/aidl/IBookManager.aidl`
，也就是会在main下面新建一个aidl文件夹，与java文件夹同一层目录。
然后系统会自动为该文件生成对应的Java代码，Java代码生成在
`demoandtest/app/build/generated/source/aidl/debug/yorek/demoandtest/aidl/IBookManager.java`

```java
/*
 * This file is auto-generated.  DO NOT MODIFY.
 * Original file: /Users/yorek/Codes/AndroidStudioProjects/demoandtest/app/src/main/aidl/yorek/demoandtest/aidl/IBookManager.aidl
 */
package yorek.demoandtest.aidl;
// Declare any non-default types here with import statements

public interface IBookManager extends android.os.IInterface {
    /**
     * Local-side IPC implementation stub class.
     */
    public static abstract class Stub extends android.os.Binder implements yorek.demoandtest.aidl.IBookManager {
        private static final java.lang.String DESCRIPTOR = "yorek.demoandtest.aidl.IBookManager";

        /**
         * Construct the stub at attach it to the interface.
         */
        public Stub() {
            this.attachInterface(this, DESCRIPTOR);
        }

        /**
         * Cast an IBinder object into an yorek.demoandtest.aidl.IBookManager interface,
         * generating a proxy if needed.
         */
        public static yorek.demoandtest.aidl.IBookManager asInterface(android.os.IBinder obj) {
            if ((obj == null)) {
                return null;
            }
            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);
            if (((iin != null) && (iin instanceof yorek.demoandtest.aidl.IBookManager))) {
                return ((yorek.demoandtest.aidl.IBookManager) iin);
            }
            return new yorek.demoandtest.aidl.IBookManager.Stub.Proxy(obj);
        }

        @Override
        public android.os.IBinder asBinder() {
            return this;
        }

        @Override
        public boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) throws android.os.RemoteException {
            switch (code) {
                case INTERFACE_TRANSACTION: {
                    reply.writeString(DESCRIPTOR);
                    return true;
                }
                case TRANSACTION_basicTypes: {
                    data.enforceInterface(DESCRIPTOR);
                    int _arg0;
                    _arg0 = data.readInt();
                    long _arg1;
                    _arg1 = data.readLong();
                    boolean _arg2;
                    _arg2 = (0 != data.readInt());
                    float _arg3;
                    _arg3 = data.readFloat();
                    double _arg4;
                    _arg4 = data.readDouble();
                    java.lang.String _arg5;
                    _arg5 = data.readString();
                    this.basicTypes(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5);
                    reply.writeNoException();
                    return true;
                }
            }
            return super.onTransact(code, data, reply, flags);
        }

        private static class Proxy implements yorek.demoandtest.aidl.IBookManager {
            private android.os.IBinder mRemote;

            Proxy(android.os.IBinder remote) {
                mRemote = remote;
            }

            @Override
            public android.os.IBinder asBinder() {
                return mRemote;
            }

            public java.lang.String getInterfaceDescriptor() {
                return DESCRIPTOR;
            }

            /**
             * Demonstrates some basic types that you can use as parameters
             * and return values in AIDL.
             */
            @Override
            public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException {
                android.os.Parcel _data = android.os.Parcel.obtain();
                android.os.Parcel _reply = android.os.Parcel.obtain();
                try {
                    _data.writeInterfaceToken(DESCRIPTOR);
                    _data.writeInt(anInt);
                    _data.writeLong(aLong);
                    _data.writeInt(((aBoolean) ? (1) : (0)));
                    _data.writeFloat(aFloat);
                    _data.writeDouble(aDouble);
                    _data.writeString(aString);
                    mRemote.transact(Stub.TRANSACTION_basicTypes, _data, _reply, 0);
                    _reply.readException();
                } finally {
                    _reply.recycle();
                    _data.recycle();
                }
            }
        }

        static final int TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0);
    }

    /**
     * Demonstrates some basic types that you can use as parameters
     * and return values in AIDL.
     */
    public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, java.lang.String aString) throws android.os.RemoteException;
}

```
我们可以看到AIDL生成的文件时一个继承至IInterface的接口，里面有一个公有内部类`Stub`，这个类就是一个Binder类。当客户端与服务端都位于同一个进程时，方法不会走跨进程的`transact`过程，而当不同进程时，会由`Stub`的内部代理类`Proxy`来调用`transact`过程。

下面介绍这两个类的每个方法的含义：

- Stub
  * DESCRIPTOR  
    Binder的唯一标识，一般用当前Binder的完整类名。
  * asInterface(android.os.IBinder obj)  
    用户将服务器的Binder对象转换成客户端所需要的AIDL接口类型的对象。这种转换是区分进程的，如果客户端和服务器端位于同一进程，那么返回的就是服务器端的Stub本身，否则是封装后的Stub.proxy代理对象。
  * asBinder  
    返回当前Binder对象
  * onTransact   
    该方法会由`Proxy`中对应的功能函数(如上面`basicTypes `)调用，`IBinder`接口的具体实现者`Binder`的`transact`方法会调用`onTransact`方法，并返回boolean结果。该方法运行在服务端中的`Binder`线程池中。

> 如果此方法返回false，那么客户端的请求会失败，因此我们可以利用这个特性来做权限验证。

- Proxy
  * basicTypes
    该方法运行在客户端。内部实现：
    1. 创建方法所需的输入型Parcel对象_data、输出型Parcel对象_reply，如果有返回值还会创建返回值对象_result
    2. 先向_data中写入Binder的标识`DESCRIPTOR`，然后写入方法的参数
    3. 调用`transact `发起PRC(Remote Procedure Calls，远程过程调用)，同时挂起当前线程。
    4. 客户端的`onTransact`方法调用，PRC返回后，当前线程继续执行，从_reply中读取PRC返回结果，若有返回值，继续读取返回值
    5. 回收_data、_reply，如果有返回值，返回_result

> 需要注意两点：1. 客户端发起远程请求时，当前线程会被挂起直到服务端进程返回数据，因此如果远程方法是耗时的，不能在UI线程发起远程请求；2. 服务器端的Binder方法运行在Binder线程池中，所以Binder方法不管是否耗时都应该采用同步的方式实现，因为它已经运行在一个线程中了。

![Binder工作机制](http://upload-images.jianshu.io/upload_images/2525608-f390cdb7f16f45dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

Binder中还有很重要的两个方法`linkToDeath`以及`unlinkToDeath`。Binder运行在服务端进程中，如果服务端进程被杀死，那么客户端到服务端的Binder会断裂(称之为Binder死亡)，这会导致我们远程调用失败。
为了解决这个问题，Binder提供了上述两个方法，通过`linkToDeath`我们可以给Binder设置一个死亡代理`DeathRecipient`。当Binder死亡时会回调`DeathRecipient`的`binderDied`方法，在里面我们可以移除之前的Binder代理并重新绑定远程服务：
```java
private IBinder.DeathRecipient mDeathRecipient = new IBinder.DeathRecipient() {
    @Override
    public void binderDied() {
        if (mBookManager == null)  return;
        mBookManager.asBinder().unlinkToDeath(mDeathRecipient, 0);
        mBookManager = null;
        // 接下来重新绑定远程Service
    }
}
```
在客户端绑定远程服务成功后，给binder设置死亡代理:
```java
binder.linkToDeath(mDeathRecipient, 0);
```
同时还有另一种方式重新连接Service，即在onServiceDisconnected中重连。这两种方法的区别在于`onServiceDisconnected`在客户端的UI线程执行，而`binderDied`在Binder线程池中回调，因此在`binderDied`方法中不能访问UI线程。
另外通过Binder的`isBinderAlive()`方法也可以判断Binder是否死亡。
