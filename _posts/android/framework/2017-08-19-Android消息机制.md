---
excerpt: "Android的消息机制指Handler的运行机制，由Message、Handler、MessageQueue以及Looper组成。"
header:
  teaser: /assets/images/android/Handler处理消息的过程.png
  overlay_image: /assets/images/android/Handler处理消息的过程.png
  overlay_filter: 0.5
categories:
  - Android
tags:
  - 消息机制
  - Handler
  - Message
  - MessageQueue
  - Looper
  - ThreadLocal
toc: true
toc_label: "目录"
---

Android中的消息机制主要指Handler的运行机制，Handler的运行需要底层的MessageQueue和Looper支撑。  

Handler可以将一个任务切换到Handler所在的线程中去执行。

MessageQueue的中文翻译为消息队列，顾名思义，其内部可以存储一组Message，以队列的形式提供插入和删除工作，**但是其内部实现是一个单链表**。  

Looper会以无限循环的方式在MessageQueue中查找新消息，如有则处理消息，否则阻塞(sè)。  
Looper中还有一个特殊的概念：ThreadLocal，ThreadLocal可以在不同线程中互不干扰的存储并提供数据。

## 1 Android消息机制概述
Android消息机制由Handler、Message、MessageQueue、Looper四个要素组成。我们接触最多的就是Handler，因为我们需要通过它在主线程执行UI操作。  
另外，UI操作的线程检测在`ViewRootImpl#checkThread`中。ViewRootImpl对于Activity来说，只有在onResume之后，才会创建ViewRootImpl，在此之后在子线程执行UI操作才会报错。
```java
void checkThread() {
    if (mThread != Thread.currentThread()) {
        throw new CalledFromWrongThreadException(
                "Only the original thread that created a view hierarchy can touch its views.");
    }
}
```
[更多可以查看另一篇文章](/android/android%20sdk/Window%E4%B8%8EWindowManager/#31-activity%E7%9A%84window%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B)

Handler在创建时会采用当前线程的Looper来构建内部的消息循环模型，如果当前线程没有Looper则会运行时异常`Can't create handler inside thread that has not called Looper.prepare()`。解决办法就是在线程中创建Looper或者在有Looper的线程中创建Handler。至于Activity的Looper在哪创建的，View的post方法为什么可以直接执行等会再后面说。

Handler创建完成之后，其内部的Looper以及MessageQueue就可以和Handler一起工作了。通过Handler的post(Runnable)方法或者send方法发送Message（post的Runnable对象也会被封装成为Message），这个Message会被enqueueMessage到MessageQueue中，然后Looper会一直取这些消息。取到消息后会被Handler的handleMessage处理。由于Looper运行在创建Handler所在的线程，这样Handler中的业务逻辑就被切换到创建Handler所在的线程中去了。

## 2 Android消息机制分析
*本章源码基于Android 7.1 N_MR1*  

由于Looper离不开ThreadLocal，因此我们先说说ThreadLocal。
### 2.1 ThreadLocal的工作原理
ThreadLocal是一个线程内部的数据存储类，通过它可以在各个线程中存储不同的数据。它一般有两个使用场景：
1. 某些数据是以线程为作用域且不同线程具有不同的数据时
2. 在复杂逻辑下对象的传递

首先我们看一下它在Looper中的用法：
```java
public final class Looper {
    ...
    // sThreadLocal.get() will return null unless you've called prepare().
    static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();
    ...
    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }
    ...
    public static @Nullable Looper myLooper() {
        return sThreadLocal.get();
    }
    ...
}
```

从上面的代码可以看出，ThreadLocal的使用方法非常简单，主要是其get/set方法。下面我们看一下其内部实现：
```java
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
```
Thread有一个成员变量`ThreadLocal.ThreadLocalMap threadLocals = null;`，`getMap(Thread)`返回的就是这个成员。如果map不为空，则以当前线程为key设置值，否则创建ThreadLocalMap并把value作为值。
下面我们看看`createMap`方法，此方法会直接创建ThreadLocalMap类：
```java
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}

ThreadLocalMap(ThreadLocal firstKey, Object firstValue) {
    table = new Entry[INITIAL_CAPACITY];
    int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
    table[i] = new Entry(firstKey, firstValue);
    size = 1;
    setThreshold(INITIAL_CAPACITY);
}
```
我们注意到i的生成，ThreadLocal的特点就在于这个i。下面我们看一下`ThreadLocal#threadLocalHashCode`
```java
private final int threadLocalHashCode = nextHashCode();
private static AtomicInteger nextHashCode = new AtomicInteger();

private static int nextHashCode() {
    return nextHashCode.getAndAdd(HASH_INCREMENT);
}
```
注意到这里的nextHashCode变量，这是一个静态的原子整型，**threadLocalHashCode的初始化都会导致nextHashCode变量增加HASH_INCREMENT，因此每一个ThreadLocal的threadLocalHashCode都不同，以此来区分不同的线程。**

我们再来看看get方法：
```java
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null)
            return (T)e.value;
    }
    return setInitialValue();
}
```
get方法非常清晰明了，不需要过多的解释。

### 2.2 Message源码解析
Message我们很熟悉，所以我们这里重点说说Message的复用机制。（在IPC机制的Messenger中也描述过与Message）
```java
public final class Message implements Parcelable {
    public int what;
    public int arg1;
    public int arg2;
    public Object obj;

    /*package*/ static final int FLAG_IN_USE = 1 << 0;
    /*package*/ Runnable callback;

    // sometimes we store linked lists of these things
    /*package*/ Message next;

    private static final Object sPoolSync = new Object();
    private static Message sPool;
    private static int sPoolSize = 0;

    private static final int MAX_POOL_SIZE = 50;
    ...
}
```
我们先看一下成员变量：what、arg1、arg2、obj都不用说了。
callback是一个Runnable类型的对象，我们使用`Handler#post(Runnable)`会将Runnable封装成一个Message，post出来的Runnable就被赋值给callback变量。

next、sPool、MAX_POOL_SIZE、sPoolSize都与Message的复用有关，其数据结构是一个单链表。
下面我们看看`obtain`方法：
```java
/**
 * Return a new Message instance from the global pool. Allows us to
 * avoid allocating new objects in many cases.
 */
public static Message obtain() {
    synchronized (sPoolSync) {
        if (sPool != null) {
            Message m = sPool;
            sPool = m.next;
            m.next = null;
            m.flags = 0; // clear in-use flag
            sPoolSize--;
            return m;
        }
    }
    return new Message();
}
```
这里对Message的复用做了同步处理，如果Message池不为空，将sPool指针后移一个，将原来的头结点m返回，同时计数减1。这是非常熟悉的单链表操作。

其他的obtain方法的重载都会调用此方法，然后将传入参数重新赋值。

然后看一下回收相关的操作：
```java
private static boolean gCheckRecycle = true;

/** @hide */
public static void updateCheckRecycle(int targetSdkVersion) {
    if (targetSdkVersion < Build.VERSION_CODES.LOLLIPOP) {
        gCheckRecycle = false;
    }
}

/**
 * Return a Message instance to the global pool.
 * <p>
 * You MUST NOT touch the Message after calling this function because it has
 * effectively been freed.  It is an error to recycle a message that is currently
 * enqueued or that is in the process of being delivered to a Handler.
 * </p>
 */
public void recycle() {
    if (isInUse()) {
        if (gCheckRecycle) {
            throw new IllegalStateException("This message cannot be recycled because it "
                    + "is still in use.");
        }
        return;
    }
    recycleUnchecked();
}

/**
 * Recycles a Message that may be in-use.
 * Used internally by the MessageQueue and Looper when disposing of queued Messages.
 */
void recycleUnchecked() {
    // Mark the message as in use while it remains in the recycled object pool.
    // Clear out all other details.
    flags = FLAG_IN_USE;
    what = 0;
    arg1 = 0;
    arg2 = 0;
    obj = null;
    replyTo = null;
    sendingUid = -1;
    when = 0;
    target = null;
    callback = null;
    data = null;

    synchronized (sPoolSync) {
        if (sPoolSize < MAX_POOL_SIZE) {
            next = sPool;
            sPool = this;
            sPoolSize++;
        }
    }
}
```
回收操作会由`recycle`方法调用`recycleUnchecked`方法。  

`recycleUnchecked`方法将会清除除了标记位之后的所有信息，然后添加到Message池中，计数自增。  

如果Message的flags为FLAG_IN_USE，`recycle`会return，而不会执行`recycleUnchecked`。也就是说Message在`obtain`时标志位会复位，然后如果其要被回收，第一次走`recycle`方法时，`isInUse()`返回false，这使得`recycleUnchecked`可以执行，此后标志位会变成FLAG_IN_USE。在Message没有重新`obtain`之前，继续执行`recycle`将不会执行`recycleUnchecked`。这就保证了Message池中的对象都是不同的。

### 2.3 MessageQueue工作原理
MessageQueue主要包含两个操作：插入和读取，其对应的方法是`enqueueMessage`和`next`。MessageQueue其内部是通过单链表来维护消息队列的，这是因为`enqueueMessage`时会根据`Message.when`来插入，基于这样的特点采用单链表效率比较高。
首先我们看一下`enqueueMessage`方法：
```java
boolean enqueueMessage(Message msg, long when) {
    ...
    synchronized (this) {
        ...
        msg.markInUse();
        msg.when = when;
        Message p = mMessages;
        boolean needWake;
        if (p == null || when == 0 || when < p.when) {
            // New head, wake up the event queue if blocked.
            msg.next = p;
            mMessages = msg;
            needWake = mBlocked;
        } else {
            // Inserted within the middle of the queue.  Usually we don't have to wake
            // up the event queue unless there is a barrier at the head of the queue
            // and the message is the earliest asynchronous message in the queue.
            needWake = mBlocked && p.target == null && msg.isAsynchronous();
            Message prev;
            for (;;) {
                prev = p;
                p = p.next;
                if (p == null || when < p.when) {
                    break;
                }
                if (needWake && p.isAsynchronous()) {
                    needWake = false;
                }
            }
            msg.next = p; // invariant: p == prev.next
            prev.next = msg;
        }

        // We can assume mPtr != 0 because mQuitting is false.
        if (needWake) {
            nativeWake(mPtr);
        }
    }
    return true;
}
```
`enqueueMessage`方法就是单链表的插入操作，分为头结点以及非头结点两个部分插入。

接着看`next`方法：
```java
Message next() {
    // Return here if the message loop has already quit and been disposed.
    // This can happen if the application tries to restart a looper after quit
    // which is not supported.
    final long ptr = mPtr;
    if (ptr == 0) {
        return null;
    }

    int pendingIdleHandlerCount = -1; // -1 only during first iteration
    int nextPollTimeoutMillis = 0;
    for (;;) {
        if (nextPollTimeoutMillis != 0) {
            Binder.flushPendingCommands();
        }

        nativePollOnce(ptr, nextPollTimeoutMillis);

        synchronized (this) {
            // Try to retrieve the next message.  Return if found.
            final long now = SystemClock.uptimeMillis();
            Message prevMsg = null;
            Message msg = mMessages;
            if (msg != null && msg.target == null) {
                // Stalled by a barrier.  Find the next asynchronous message in the queue.
                do {
                    prevMsg = msg;
                    msg = msg.next;
                } while (msg != null && !msg.isAsynchronous());
            }
            if (msg != null) {
                if (now < msg.when) {
                    // Next message is not ready.  Set a timeout to wake up when it is ready.
                    nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);
                } else {
                    // Got a message.
                    mBlocked = false;
                    if (prevMsg != null) {
                        prevMsg.next = msg.next;
                    } else {
                        mMessages = msg.next;
                    }
                    msg.next = null;
                    if (DEBUG) Log.v(TAG, "Returning message: " + msg);
                    msg.markInUse();
                    return msg;
                }
            } else {
                // No more messages.
                nextPollTimeoutMillis = -1;
            }

            // Process the quit message now that all pending messages have been handled.
            if (mQuitting) {
                dispose();
                return null;
            }
            ...
        }
        ...
    }
}
```
`next`方法的重点是for(;;)循环，如果MessageQueue中有可以立刻处理的Message，那么会返回这条消息并且从链表中移除。否则，会等待一段时间或者一直阻塞在这里。

### 2.4 Looper工作原理
Looper在Android消息机制中扮演着消息循环的角色，它会一直从MessageQueue中取Message；若没有消息则会阻塞。

在一个没有Looper存在的线程中创建Handler就会报错，我们可以使用`prepare()`方法在当前线程创建一个Looper，接着通过`Looper.loop()`来开启消息循环。Looper除了`prepare()`之外，还有专门为主线程准备的`prepareMainLooper()`方法，其本质也是通过`prepare`来实现的。

Looper也是可以退出的，其提供了`quit`和`quitSafely`两个方法。前者会直接退出Looper；而后者只是设定一个退出标记，直到消息队列中已有的事情处理完毕才安全退出。`quit`和`quitSafely`都是调用了MessageQueue中的`quit(boolean safe)`方法。Looper退出后，使用Handler发送Message会失败并返回false。在子线程中，如果手动为其创建了Looper，那么在所有事情处理完毕之后应该调用`quit`方法来终止消息循环，否则该子线程会一直处于等待状态，在退出Looper之后就会立刻终止。
```java
public final class Looper {
    ...
    static final ThreadLocal<Looper> sThreadLocal = new ThreadLocal<Looper>();
    private static Looper sMainLooper;  // guarded by Looper.class

    final MessageQueue mQueue;
    final Thread mThread;
    ...
     /** Initialize the current thread as a looper.
      * This gives you a chance to create handlers that then reference
      * this looper, before actually starting the loop. Be sure to call
      * {@link #loop()} after calling this method, and end it by calling
      * {@link #quit()}.
      */
    public static void prepare() {
        prepare(true);
    }

    private static void prepare(boolean quitAllowed) {
        if (sThreadLocal.get() != null) {
            throw new RuntimeException("Only one Looper may be created per thread");
        }
        sThreadLocal.set(new Looper(quitAllowed));
    }

    /**
     * Initialize the current thread as a looper, marking it as an
     * application's main looper. The main looper for your application
     * is created by the Android environment, so you should never need
     * to call this function yourself.  See also: {@link #prepare()}
     */
    public static void prepareMainLooper() {
        prepare(false);
        synchronized (Looper.class) {
            if (sMainLooper != null) {
                throw new IllegalStateException("The main Looper has already been prepared.");
            }
            sMainLooper = myLooper();
        }
    }

    /**
     * Run the message queue in this thread. Be sure to call
     * {@link #quit()} to end the loop.
     */
    public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
        }
        final MessageQueue queue = me.mQueue;

        // Make sure the identity of this thread is that of the local process,
        // and keep track of what that identity token actually is.
        Binder.clearCallingIdentity();
        final long ident = Binder.clearCallingIdentity();

        for (;;) {
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }

            // This must be in a local variable, in case a UI event sets the logger
            final Printer logging = me.mLogging;
            if (logging != null) {
                logging.println(">>>>> Dispatching to " + msg.target + " " +
                        msg.callback + ": " + msg.what);
            }

            final long traceTag = me.mTraceTag;
            if (traceTag != 0 && Trace.isTagEnabled(traceTag)) {
                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));
            }
            try {
                msg.target.dispatchMessage(msg);
            } finally {
                if (traceTag != 0) {
                    Trace.traceEnd(traceTag);
                }
            }

            if (logging != null) {
                logging.println("<<<<< Finished to " + msg.target + " " + msg.callback);
            }

            // Make sure that during the course of dispatching the
            // identity of the thread wasn't corrupted.
            final long newIdent = Binder.clearCallingIdentity();
            if (ident != newIdent) {
                Log.wtf(TAG, "Thread identity changed from 0x"
                        + Long.toHexString(ident) + " to 0x"
                        + Long.toHexString(newIdent) + " while dispatching to "
                        + msg.target.getClass().getName() + " "
                        + msg.callback + " what=" + msg.what);
            }

            msg.recycleUnchecked();
        }
    }

    private Looper(boolean quitAllowed) {
        mQueue = new MessageQueue(quitAllowed);
        mThread = Thread.currentThread();
    }

    /**
     * Quits the looper.
     * <p>
     * Causes the {@link #loop} method to terminate without processing any
     * more messages in the message queue.
     * </p><p>
     * Any attempt to post messages to the queue after the looper is asked to quit will fail.
     * For example, the {@link Handler#sendMessage(Message)} method will return false.
     * </p><p class="note">
     * Using this method may be unsafe because some messages may not be delivered
     * before the looper terminates.  Consider using {@link #quitSafely} instead to ensure
     * that all pending work is completed in an orderly manner.
     * </p>
     *
     * @see #quitSafely
     */
    public void quit() {
        mQueue.quit(false);
    }

    /**
     * Quits the looper safely.
     * <p>
     * Causes the {@link #loop} method to terminate as soon as all remaining messages
     * in the message queue that are already due to be delivered have been handled.
     * However pending delayed messages with due times in the future will not be
     * delivered before the loop terminates.
     * </p><p>
     * Any attempt to post messages to the queue after the looper is asked to quit will fail.
     * For example, the {@link Handler#sendMessage(Message)} method will return false.
     * </p>
     */
    public void quitSafely() {
        mQueue.quit(true);
    }
}
```
Looper最重要的方法是loop方法，只有调用了此方法，MessageQueue才会真正开始运行。`loop`是一个死循环，唯一跳出循环的条件是`MessageQueue#next`返回null。当Looper调用`quit`或者`quitSafely`时，Looper会调用MessageQueue的`quit`方法，此方法会将`mQuitting`设为true，所以在MessageQueue的`next`方法循环中会返回null。当没有Message时，`loop`方法会阻塞在`queue.next()`处。若来了新Message，Looper会调用`msg.target.dispatchMessage(msg);`将Message交给msg.target的`dispatchMessage`方法处理。而msg.target是一个Handler，这样Handler发送的消息最后又会被Handler自己处理。

### 2.5 Handler工作原理
Handler的主要功能是发送消息以及处理消息。发送消息可以通过send和post的一些方法来发送，下面我们看看这些代码：
```java
private static Message getPostMessage(Runnable r) {
    Message m = Message.obtain();
    m.callback = r;
    return m;
}

private static Message getPostMessage(Runnable r, Object token) {
    Message m = Message.obtain();
    m.obj = token;
    m.callback = r;
    return m;
}

public final boolean post(Runnable r)
{
   return  sendMessageDelayed(getPostMessage(r), 0);
}

public final boolean postAtTime(Runnable r, long uptimeMillis)
{
    return sendMessageAtTime(getPostMessage(r), uptimeMillis);
}

public final boolean postAtTime(Runnable r, Object token, long uptimeMillis)
{
    return sendMessageAtTime(getPostMessage(r, token), uptimeMillis);
}

public final boolean postDelayed(Runnable r, long delayMillis)
{
    return sendMessageDelayed(getPostMessage(r), delayMillis);
}

public final boolean postAtFrontOfQueue(Runnable r)
{
    return sendMessageAtFrontOfQueue(getPostMessage(r));
}

public final boolean sendMessage(Message msg)
{
    return sendMessageDelayed(msg, 0);
}

public final boolean sendEmptyMessage(int what)
{
    return sendEmptyMessageDelayed(what, 0);
}

public final boolean sendEmptyMessageDelayed(int what, long delayMillis) {
    Message msg = Message.obtain();
    msg.what = what;
    return sendMessageDelayed(msg, delayMillis);
}

public final boolean sendEmptyMessageAtTime(int what, long uptimeMillis) {
    Message msg = Message.obtain();
    msg.what = what;
    return sendMessageAtTime(msg, uptimeMillis);
}

public final boolean sendMessageDelayed(Message msg, long delayMillis)
{
    if (delayMillis < 0) {
        delayMillis = 0;
    }
    return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
}

public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
                this + " sendMessageAtTime() called with no mQueue");
        Log.w("Looper", e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, uptimeMillis);
}

public final boolean sendMessageAtFrontOfQueue(Message msg) {
    MessageQueue queue = mQueue;
    if (queue == null) {
        RuntimeException e = new RuntimeException(
            this + " sendMessageAtTime() called with no mQueue");
        Log.w("Looper", e.getMessage(), e);
        return false;
    }
    return enqueueMessage(queue, msg, 0);
}

private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
    msg.target = this;
    if (mAsynchronous) {
        msg.setAsynchronous(true);
    }
    return queue.enqueueMessage(msg, uptimeMillis);
}
```
我们可以看到，通过post发送的Runnable对象都被封装成了Message，Runnable被赋值给callback属性。通过send发送的，若没有Message，那么也被包装成Message。最后都会通过`queue.enqueueMessage(msg, uptimeMillis);`向MessageQueue中插入新消息。这条消息在Looper的loop()中被MessageQueue的`next`方法传递给`msg.target.dispatchMessage`来处理，这时Handler就进入了处理消息的阶段。
我们看下`dispatchMessage`方法的实现：
```java
/**
 * Handle system messages here.
 */
public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);
    } else {
        if (mCallback != null) {
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);
    }
}

private static void handleCallback(Message message) {
    message.callback.run();
}

/**
 * Callback interface you can use when instantiating a Handler to avoid
 * having to implement your own subclass of Handler.
 *
 * @param msg A {@link android.os.Message Message} object
 * @return True if no further handling is desired
 */
public interface Callback {
    public boolean handleMessage(Message msg);
}

/**
 * Subclasses must implement this to receive messages.
 */
public void handleMessage(Message msg) {
}
```
Handler处理消息的过程如下：
1. 如果Message的callback不为空，则执行callback的run方法。
2. 如果mCallback不为空，就调用mCallback的`handleMessage`方法处理消息。如果mCallback没有处理，则继续下一步，否则return。Callback接口存在的意义就是可以使用Callback来创建Handler而不需要派生子类。`Handler handler = new Handler(callback);`
3. 最后，如果mCallback为null或者mCallback没有处理消息，Handler的`handleMessage`会被调用。Handler的子类为了能够接受Message必须实现这个方法，因此其在Handler里面的实现是空的。

其流程整理如图如下：  
![Handler处理消息的过程]({{ basepath }}/assets/images/android/Handler处理消息的过程.png)


以下是Android消息机制的简单描述图。

注意，图中虚线部分不存在这样的调用关系，只是对于一个Message来说，存在这样的先后的逻辑关系。  
![Android消息机制简单描述]({{ basepath }}/assets/images/android/Android消息机制简单描述.png)

## 3 主线程的消息循环
Android的主线程就是ActivityThread，主线程的入口方法和Java程序一样也是`main`。我们看一下这个方法`ActivityThread#main`
```java
public static void main(String[] args) {
    ....
    Looper.prepareMainLooper();

    ActivityThread thread = new ActivityThread();
    thread.attach(false);

    if (sMainThreadHandler == null) {
        sMainThreadHandler = thread.getHandler();
    }

    if (false) {
        Looper.myLooper().setMessageLogging(new
                LogPrinter(Log.DEBUG, "ActivityThread"));
    }

    // End of event ActivityThreadMain.
    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
    Looper.loop();

    throw new RuntimeException("Main thread loop unexpectedly exited");
}
```
可以看到，在`main`方法中为主线程开启了Looper，然后在最后调用了`loop`方法。这样主线程就一直在运行，如果`loop()`方法因故退出，会抛出运行时异常` throw new RuntimeException("Main thread loop unexpectedly exited");`。

主线程的消息循环开启后，ActivityThread还有一个Handler来和消息队列进行交互，这个Handler就是ActivityThread.H，它内部定义了一组消息类型，主要包含了四大组件的启动和停止等过程：
```java
final H mH = new H();

private class H extends Handler {
    public static final int LAUNCH_ACTIVITY         = 100;
    public static final int PAUSE_ACTIVITY          = 101;
    public static final int PAUSE_ACTIVITY_FINISHING= 102;
    public static final int STOP_ACTIVITY_SHOW      = 103;
    public static final int STOP_ACTIVITY_HIDE      = 104;
    public static final int SHOW_WINDOW             = 105;
    public static final int HIDE_WINDOW             = 106;
    public static final int RESUME_ACTIVITY         = 107;
    public static final int SEND_RESULT             = 108;
    public static final int DESTROY_ACTIVITY        = 109;
    public static final int BIND_APPLICATION        = 110;
    public static final int EXIT_APPLICATION        = 111;
    public static final int NEW_INTENT              = 112;
    public static final int RECEIVER                = 113;
    public static final int CREATE_SERVICE          = 114;
    public static final int SERVICE_ARGS            = 115;
    public static final int STOP_SERVICE            = 116;

    public static final int CONFIGURATION_CHANGED   = 118;
    public static final int CLEAN_UP_CONTEXT        = 119;
    public static final int GC_WHEN_IDLE            = 120;
    public static final int BIND_SERVICE            = 121;
    public static final int UNBIND_SERVICE          = 122;
    public static final int DUMP_SERVICE            = 123;
    public static final int LOW_MEMORY              = 124;
    public static final int ACTIVITY_CONFIGURATION_CHANGED = 125;
    public static final int RELAUNCH_ACTIVITY       = 126;
    public static final int PROFILER_CONTROL        = 127;
    public static final int CREATE_BACKUP_AGENT     = 128;
    public static final int DESTROY_BACKUP_AGENT    = 129;
    public static final int SUICIDE                 = 130;
    public static final int REMOVE_PROVIDER         = 131;
    public static final int ENABLE_JIT              = 132;
    public static final int DISPATCH_PACKAGE_BROADCAST = 133;
    public static final int SCHEDULE_CRASH          = 134;
    public static final int DUMP_HEAP               = 135;
    public static final int DUMP_ACTIVITY           = 136;
    public static final int SLEEPING                = 137;
    public static final int SET_CORE_SETTINGS       = 138;
    public static final int UPDATE_PACKAGE_COMPATIBILITY_INFO = 139;
    public static final int TRIM_MEMORY             = 140;
    public static final int DUMP_PROVIDER           = 141;
    public static final int UNSTABLE_PROVIDER_DIED  = 142;
    public static final int REQUEST_ASSIST_CONTEXT_EXTRAS = 143;
    public static final int TRANSLUCENT_CONVERSION_COMPLETE = 144;
    public static final int INSTALL_PROVIDER        = 145;
    public static final int ON_NEW_ACTIVITY_OPTIONS = 146;
    public static final int CANCEL_VISIBLE_BEHIND = 147;
    public static final int BACKGROUND_VISIBLE_BEHIND_CHANGED = 148;
    public static final int ENTER_ANIMATION_COMPLETE = 149;
    public static final int START_BINDER_TRACKING = 150;
    public static final int STOP_BINDER_TRACKING_AND_DUMP = 151;
    public static final int MULTI_WINDOW_MODE_CHANGED = 152;
    public static final int PICTURE_IN_PICTURE_MODE_CHANGED = 153;
    public static final int LOCAL_VOICE_INTERACTION_STARTED = 154;

    String codeToString(int code) {
        if (DEBUG_MESSAGES) {
            switch (code) {
                case LAUNCH_ACTIVITY: return "LAUNCH_ACTIVITY";
                case PAUSE_ACTIVITY: return "PAUSE_ACTIVITY";
                case PAUSE_ACTIVITY_FINISHING: return "PAUSE_ACTIVITY_FINISHING";
                case STOP_ACTIVITY_SHOW: return "STOP_ACTIVITY_SHOW";
                case STOP_ACTIVITY_HIDE: return "STOP_ACTIVITY_HIDE";
                case SHOW_WINDOW: return "SHOW_WINDOW";
                case HIDE_WINDOW: return "HIDE_WINDOW";
                case RESUME_ACTIVITY: return "RESUME_ACTIVITY";
                case SEND_RESULT: return "SEND_RESULT";
                case DESTROY_ACTIVITY: return "DESTROY_ACTIVITY";
                case BIND_APPLICATION: return "BIND_APPLICATION";
                ...
            }
        }
        return Integer.toString(code);
    }
    public void handleMessage(Message msg) {
        if (DEBUG_MESSAGES) Slog.v(TAG, ">>> handling: " + codeToString(msg.what));
        switch (msg.what) {
            case LAUNCH_ACTIVITY: {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityStart");
                final ActivityClientRecord r = (ActivityClientRecord) msg.obj;

                r.packageInfo = getPackageInfoNoCheck(
                        r.activityInfo.applicationInfo, r.compatInfo);
                handleLaunchActivity(r, null, "LAUNCH_ACTIVITY");
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            } break;
            case RELAUNCH_ACTIVITY: {
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "activityRestart");
                ActivityClientRecord r = (ActivityClientRecord)msg.obj;
                handleRelaunchActivity(r);
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
            } break;
            ...
        }
        Object obj = msg.obj;
        if (obj instanceof SomeArgs) {
            ((SomeArgs) obj).recycle();
        }
        if (DEBUG_MESSAGES) Slog.v(TAG, "<<< done: " + codeToString(msg.what));
    }
    ...
}
```
ActivityThread通过ApplicationThread和ActivityManagerService(AMS)进行进程间通信，AMS以IPC的方式完成ActivityThread的请求后回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，这个过程就是主线程的消息循环模型。

关于应用于AMS之间的通信，可以查看另外一篇文章[四大组件启动过程](/android/android%20sdk/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/)

另外一个问题：我们可以在应用中可以使用View的post(Runnable)方法。那么处理这个Message的Handler是谁呢？  
处理这个Message的Handler是ViewRootImpl的`ViewRootHandler`。

我们先看`View#post`
```java
public boolean post(Runnable action) {
    final AttachInfo attachInfo = mAttachInfo;
    if (attachInfo != null) {
        return attachInfo.mHandler.post(action);
    }

    // Postpone the runnable until we know on which thread it needs to run.
    // Assume that the runnable will be successfully placed after attach.
    getRunQueue().post(action);
    return true;
}
```
首先，如果有mAttachInfo，那么直接使用mAttachInfo的mHandler去处理，否则使用`getRunQueue().post(action);`处理。对后者来说，`getRunQueue()`返回的是一个`HandlerActionQueue`对象，此对象仅仅用来保存这些Runnable。真正执行要调用`executeActions(Handler)`方法，而这方法被调用是在`dispatchAttachedToWindow`方法中：
```java
void dispatchAttachedToWindow(AttachInfo info, int visibility) {
    mAttachInfo = info;
    ...
    // Transfer all pending runnables.
    if (mRunQueue != null) {
        mRunQueue.executeActions(info.mHandler);
        mRunQueue = null;
    }
    ...
}
```
可以看到，最后还是靠mAttachInfo的mHandler处理。接着我们看一下谁调用了View的`dispatchAttachedToWindow`方法：
```java
private void performTraversals() {
    ...
    if (mFirst) {
        ...
        host.dispatchAttachedToWindow(mAttachInfo, 0);
        ...
    } else {
       ...
    }
    ...
}
```
这个方法是在`ViewRootImpl#performTraversals`中被调用的。接着我们在看一下mAttachInfo的相关信息：
```java
final View.AttachInfo mAttachInfo;

public ViewRootImpl(Context context, Display display) {
    ...
    mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this);
    ...
}

final ViewRootHandler mHandler = new ViewRootHandler();

private final static int MSG_INVALIDATE = 1;
private final static int MSG_INVALIDATE_RECT = 2;
private final static int MSG_DIE = 3;
private final static int MSG_RESIZED = 4;
private final static int MSG_RESIZED_REPORT = 5;
private final static int MSG_WINDOW_FOCUS_CHANGED = 6;
private final static int MSG_DISPATCH_INPUT_EVENT = 7;
private final static int MSG_DISPATCH_APP_VISIBILITY = 8;
private final static int MSG_DISPATCH_GET_NEW_SURFACE = 9;
private final static int MSG_DISPATCH_KEY_FROM_IME = 11;
private final static int MSG_CHECK_FOCUS = 13;
private final static int MSG_CLOSE_SYSTEM_DIALOGS = 14;
private final static int MSG_DISPATCH_DRAG_EVENT = 15;
private final static int MSG_DISPATCH_DRAG_LOCATION_EVENT = 16;
private final static int MSG_DISPATCH_SYSTEM_UI_VISIBILITY = 17;
private final static int MSG_UPDATE_CONFIGURATION = 18;
private final static int MSG_PROCESS_INPUT_EVENTS = 19;
private final static int MSG_CLEAR_ACCESSIBILITY_FOCUS_HOST = 21;
private final static int MSG_INVALIDATE_WORLD = 22;
private final static int MSG_WINDOW_MOVED = 23;
private final static int MSG_SYNTHESIZE_INPUT_EVENT = 24;
private final static int MSG_DISPATCH_WINDOW_SHOWN = 25;
private final static int MSG_REQUEST_KEYBOARD_SHORTCUTS = 26;
private final static int MSG_UPDATE_POINTER_ICON = 27;

final class ViewRootHandler extends Handler {
    @Override
    public String getMessageName(Message message) {
        switch (message.what) {
            case MSG_INVALIDATE:
                return "MSG_INVALIDATE";
            case MSG_INVALIDATE_RECT:
                return "MSG_INVALIDATE_RECT";
            ...
        }
        return super.getMessageName(message);
    }

    @Override
    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        if (msg.what == MSG_REQUEST_KEYBOARD_SHORTCUTS && msg.obj == null) {
            // Debugging for b/27963013
            throw new NullPointerException(
                    "Attempted to call MSG_REQUEST_KEYBOARD_SHORTCUTS with null receiver:");
        }
        return super.sendMessageAtTime(msg, uptimeMillis);
    }

    @Override
    public void handleMessage(Message msg) {
        switch (msg.what) {
        case MSG_INVALIDATE:
            ((View) msg.obj).invalidate();
            break;
        case MSG_INVALIDATE_RECT:
            final View.AttachInfo.InvalidateInfo info = (View.AttachInfo.InvalidateInfo) msg.obj;
            info.target.invalidate(info.left, info.top, info.right, info.bottom);
            info.recycle();
            break;
        ...
        }
    }
}
```
可以看到ViewRootHandler处理的是一些和View相关的事情。
