---
title: "Android四大组件(3)——Broadcasts"
excerpt: "广播的注册、发送以及带权限的广播"
categories:
  - Android
tags:
  - Broadcasts
toc: true
toc_label: "目录"
---

本章的主要内容是[Broadcasts](https://developer.android.com/guide/components/broadcasts.html)

Broadcasts是一种通讯组件，Android应用程序可以发送或接收来自Android系统和其他Android应用程序的广播消息，类似于观察者设计模式。当感兴趣的事件发生时，这些广播被发送。例如，当各种系统事件（例如系统启动或设备开始充电）发生时，Android系统会发送广播。应用程序还可以发送自定义广播，例如，通知其他应用程序可能感兴趣的内容（例如，一些新数据已被下载）。

## 1 系统广播
系统广播的action的列表，可以在SDK中找到，目录是`platforms/android-25/data/broadcast_actions.txt`

### 1.1 系统广播的变更
Android 7.0及以上平台不可以发送以下系统广播，该项优化影响所有的应用，不仅仅是目标为Android 7.0的应用：
- ACTION_NEW_PICTURE
- ACTION_NEW_VIDEO

应用目标为Android 7.0 (API level 24)及更高平台必须动态注册以下广播，静态注册无效：
- CONNECTIVITY_ACTION

## 2 广播的注册
应用可以有两种方式注册BroadcastReceiver，第一种为在manifest中注册的静态注册，第二种为通过context在代码中注册的动态注册。

### 2.1 静态注册
通过静态注册的receiver，在应用安装时系统包管理器会注册此receiver。此receiver会变成应用的一个独立入口点，这意味着如果应用没有正在运行，系统可以启动应用然后在传递广播。
系统会创建新的BroadcastReceiver组件处理每一个接收到的广播。该对象仅仅在调用`onReceive(Context, Intent)`方法期间才是合法的，一旦该方法返回了，系统会认为此组件不再是active状态。

### 2.2 动态注册
动态注册时需要注意，不再需要该接受者或者context不再合法时`unregisterReceiver`。
动态注册的广播接收者只要它们注册的上下文有效就一直接收广播。例如，如果用Activity的context注册，主要Activity不被销毁，你就可以接收广播。如果使用Application的context，应用在运行时都可以接收广播。

>1. 在`onReceive`中不易进行耗时操作，其最长只有10s的周期。如果需要多一点点时间执行作业的话，可以使用`goAsync()`或者启动`JobSchedule`
>2. 如果只需要应用内广播，可以使用本地广播`LocalBroadcastManager.registerReceiver(BroadcastReceiver, IntentFilter)`来替代。

## 3 广播的发送
Android提供了四种广播的发送方式：
1. `sendOrderedBroadcast(Intent, String)`发送有序广播  
该广播一次发送给一个接受者，每个接受者轮流执行，该广播可以携带结果给下一个接受者，或者被接受者丢弃，这样就不会传递给下一个接受者了。接受者的顺序按照`android:priority`排列，同一优先级的广播接收者将会无序执行。
2. `sendBroadcast(Intent)`发送普通广播  
3. `sendStickyBroadcast` or `sendStickyOrderedBroadcast`发送粘性广播，不过此类广播由于不安全（都能访问）、没有保护（都能修改）以及其他的问题，已经被弃用了。
4. `LocalBroadcastManager.sendBroadcast`发送本地广播  
在不需要发送跨app广播时，发送本地广播是最佳的选择。第一，其效率比较高(因为不用考虑IPC)；第二，也不用当心其他应用接收或者发送该广播而导致的安全性问题。

> 如果想要只发送广播给特定的应用，可以使用Intent的`setPackage(String)`方法

## 4 使用权限限制广播
### 4.1 带权限发送
调用`sendBroadcast(Intent, String)`或`sendOrderedBroadcast(Intent, String, BroadcastReceiver，Handler, int, String, Bundle)`时，可以指定权限参数。 只有已经请求了标签中的权限标签（或者因为是危险权限后面被运行时授予的权限）的接收者才可以接收广播。
例如，下面代码发送广播：
```java
sendBroadcast(new Intent("com.example.NOTIFY"), Manifest.permission.SEND_SMS);
```
要接收广播，接收应用程序必须如下所示请求权限：
```xml
<uses-permission android：name =“android.permission.SEND_SMS”/>
```
可以指定现有的系统权限，如SEND_SMS或定义一个自定义权限 <permission>元素。

### 4.2 带权限接收
当注册广播接收者(无论是通过`registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)`注册还是通过在manifest文件<receiver>标签中)，特别申明一个权限参数时，只有已经请求了标签中的权限标签（或者因为是危险权限后面被运行时授予的权限）的接收者才可以发送广播。
例如，假设接收广播的应用已经在manifest文件中声明了如下receiver：
```xml
<receiver android:name=".MyBroadcastReceiver" android:permission="android.permission.SEND_SMS">
    <intent-filter>
        <action android:name="android.intent.action.AIRPLANE_MODE"/>   
    </intent-filter>
</receiver>
```
或者通过动态注册的receiver有如下代码：
```java
IntentFilter filter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);
registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, null );
```
为了能够发射广播到这些receivers，发射应用必须请求下面的权限：
```xml
<uses-permission android:name="android.permission.SEND_SMS"/>
```
