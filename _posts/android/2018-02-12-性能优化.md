---
title: "Android性能优化"
excerpt: "本文主要介绍一些Android的性能优化方法和程序设计的一些思想"
categories:
  - Android
tags:
 - ViewStub
 - include
 - merge
toc: true
toc_label: "目录"
toc_icon: "heart"
last_modified_at: 2018-02-12T20:39:30+08:00
---

## 1 Android的性能优化方法

本节的主要内容包括
- 布局优化
- 绘制优化
- 内存泄漏优化
- 响应速度优化
- ListView优化
- Bitmap优化
- 线程优化等等

### 1.1 布局优化

布局优化的思想就是尽量减少布局文件的层次。

首先删除布局中无用的控件和层级。其次有选择性的使用性能较低的`ViewGroup`，比如`RelativeLayout`。如果布局中既可以使用`LinearLayout`也可以使用`RelativeLayout`,那么就采用`LinearLayout`。这是因为`RelativeLayout`的功能比较复杂，它的布局过程需要话费更多的CPU时间。`FrameLayout`和`LinearLayout`一样都是一种简单高效的`ViewGroup`，因此可以考虑使用它们。但是很多时候无法单纯的通过一个`LinearLayout`或者`FrameLayout`无法实现产品效果，需要通过嵌套的方式来实现。这种情况还是建议采用`RelativeLayout`，因为`ViewGroup`的嵌套相当于增加了布局的层级，同样会降低程序的性能。**可以考虑将`RelativeLayout`替换成`ConstraintLayout`，更加强大的布局方式，也足够扁平。**

布局优化的外一种手段是采用`include`、`merge`标签和`ViewStub`。`include`标签主要用于布局重用，`merge`一般和`include`配合使用，它可以降低减少布局的层级，而`ViewStub`则提供了按需加载的功能，当需要时才会将`ViewStub`中的布局加载到内存，这样提高了程序的初始化效率。

我们可以覆盖任何被include的布局的根布局的layout属性(`android:layout_*`)，当然我们必须指定`android:layout_width`和`android:layout_height`属性，这样其他覆盖的属性才会生效。

`merge`标签一般和`include`标签一起使用从而减少布局的层级。比如，在一个竖直的线性布局中，如果被包含的布局文件中也采用竖直的`LinearLayout`，那么被包含的布局文件中的`LinearLayout`是多余的，通过`merge`标签就可以去掉多余的一层`LinearLayout`。

`ViewStub`继承至`View`，它非常轻量级且宽高都为0，因此它本身不参与任何的布局和绘制过程。`ViewStub`的意义在于按需加载所需的布局文件。比如网络异常时的界面，这个时候没有必要在整个界面初始化的时候将其加载进来，通过`ViewStub`就可以在使用的时候在加载，提高了程序初始化时的性能。  
下面是`ViewStub`的定义：  
```java
<ViewStub
    android:id="@+id/stub_import"
    android:inflatedId="@+id/panel_import"
    android:layout="@layout/progress_overlay"
    android:layout_width="fill_parent"
    android:layout_height="wrap_content"
    android:layout_gravity="bottom" />
```
其中`stub_import`是`ViewStub`的`id`，而`layout/panel_import`就是`progress_overlay`这个布局文件根元素的`id`。  
在加载`ViewStub`中的布局时，可以按照以下方式进行：  
```java
findViewById(R.id.stub_import)).setVisibility(View.VISIBLE);
// or
View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate();
```
> **Note**: `inflate`方法会返回被填充的`View`，因此我们需要与此layout进行交互时，不需要在调用`findViewById`方法。

一旦`ViewStub`调用上面的方法后，`ViewStub`会被替换掉，此时`ViewStub`不再是整个布局结构的一部分了。此外，`ViewStub`还不支持`merge`标签。

### 1.2 绘制优化
绘制优化是指`View#onDraw`方法要避免执行大量的操作。
1. `onDraw`方法不要创建新的局部对象
2. `onDraw`方法不要做耗时的任务，也不能执行成千上万此的循环操作。

> `View`的绘制帧率保证60fps最佳，这要求每帧的绘制时间不超过16ms(1000/60)。虽然程序很难保证16ms这个时间，但是尽量降低`onDraw`方法的复杂度总是切实有效的。

### 1.3 内存泄漏优化
#### 1.3.1 静态变量导致的内存泄漏
下面是两种明显的内存泄漏：
```java
public class MyCouponActivity extends BaseActivity  {

    private static Context sContext;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_my_coupon);
        sContext = this;
    }
}

// or

public class MyCouponActivity extends BaseActivity  {

    private static View sView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_my_coupon);
        sView = new View(this);
    }
}
```
这种内存泄漏，Android Studio会有提示：  
![memory_leak_static]({{ basepath }}/assets/images/memory_leak_static.png)


#### 1.3.2 单例模式导致的内存泄漏
首先提供一个单例模式，可以接受外部的注册并将外部监听器保存起来。
```java
public class TestManager {
    public interface OnDataArrivedListener {
        void onDataArrived(Object data);
    }

    private List<OnDataArrivedListener> mOnDataArrivedListeners = new ArrayList<>();

    private static class SingletonHolder {
        public static final TestManager INSTANCE = new TestManager();
    }

    private TestManager() {}

    public static TestManager getInstance() {
        return SingletonHolder.INSTANCE;
    }

    public synchronized void registerListener(OnDataArrivedListener listener) {
        if (!mOnDataArrivedListeners.contains(listener)) {
            mOnDataArrivedListeners.add(listener);
        }
    }

    public synchronized void unregisterListener(OnDataArrivedListener listener) {
        mOnDataArrivedListeners.remove(listener);
    }
}
```
然后让`Activity`实现`OnDataArrivedListener`接口并向`TestManager`注册监听。下面的代码由于缺少解注册所以会引起内存泄漏，这是因为`Activity`的对象被单例模式所持有，而单例模式的生命周期和`Application`保持一致，因此`Activity`无法被及时释放。
```java
public class AppWidgetActivity extends ActivityBase implements TestManager.OnDataArrivedListener{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_app_widget);
        TestManager.getInstance().registerListener(this);
    }

    @Override
    public void onDataArrived(Object data) {}
}
```

#### 1.3.3 属性动画导致的内存泄漏
属性动画中有一类无限循环的动画，如果`Activity`中播放此类动画且没有在`onDestory`方法中去停止动画，那么动画会一直播放下去。我们需要在`Activity#onDestory`中调用`animator.cancel()`方法来停止动画。

### 1.4 响应速度优化和ANR日志分析
响应速度优化的核心思想是避免在主线程中做耗时操作。

ANR发生后，会在`/data/anr`目录下创建一个文件`traces.txt`，分析此文件即可。

### 1.5 ListView和Bitmap优化
`ListView`和`GridView`的优化主要分为三个方面：
1. 要采用`ViewHolder`并避免在`getView`中执行耗时操作。
2. 根据列表的滑动状态来控制任务的执行频率，如当列表快速滑动时显然不太适合开启大量的异步任务。
3. 可以尝试开启硬件加速来使`ListView`的滑动更加流畅。

`Bitmap`的优化主要是通过`BitmapFactory.Options`来根据需要对图片进行采样，采样过程主要采用到了`BitmapFactory.Options#inSampleSize`参数。

### 1.6 线程优化
线程优化的思想是采用线程池，避免在程序中使用大量的`Thread`。可以考虑使用线程池。

### 1.7 一些性能优化建议
1. 避免创建过多的对象
2. 不要过多使用枚举，枚举占用的内存控件比整型大
3. 常量请使用`static final`修饰
4. 使用Android特有的数据结构，比如`SparseArray`和`Pair`等，它们具有更好的性能
5. 适当使用软应用和弱应用
6. 采用内存缓存和磁盘缓存
7. 尽量采用静态内部类，这样可以避免潜在的由于内部类导致的内存泄漏。
