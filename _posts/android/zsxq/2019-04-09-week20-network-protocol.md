---
title: "Week20-网络协议"
excerpt: "网络的五层划分是什么？TCP和UDP的区别是什么？简述TCP的三次握手过程。"
categories:
  - Android
tags:
  - 知识星球
  - 网络层次
  - TCP
  - UDP
  - 三次握手
  - TCP/IP模型
  - OSI模型
  - FIN
  - ACK
  - seq
  - SYN
toc: true
toc_label: "目录"
last_modified_at: 2019-04-09T12:06:20+08:00
---

## Question

网络模型的五层划分是什么？TCP和UDP的区别是什么？简述TCP的三次握手过程。

## Answer

网络协议分层一图简介：

<figure style="width: 80%" class="align-center">
    <img src="/assets/images/android/网络协议分层.jpg">
    <figcaption>OSI七层模型、TCP/IP四层模型、五层模型</figcaption>
</figure>

5层模型只是OSI和TCP/IP的综合模型，是业界产生出来的非官方协议模型，但是很多具体的应用。OSI是理论模型，实际应用还是TCP/IP的四层结构。

OSI的七层模型首字母可以组成一个句子：All People Seem To Need Data Processing，与之对应的七层拼写为：Application、Presentation、Session、Transport、Network、Data Link、Physical。

### 五层参考模型

网络分层从上到下分别是应用层、传输层、网络层、数据链路层和物理层。

1. 应用层  
**应用层为用户提供所需要的各种服务**，它的主要协议有HTTP、FTP、Telnet、SMTP、POP3等。

2. 传输层  
该层**为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性**。该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP)。  
TCP协议提供的是一种可靠的、通过“三次握手”来连接的数据传输服务；而UDP协议提供的则是不保证可靠的（并不是不可靠）、无连接的数据传输服务。

3. 网络层  
该层**主要解决主机到主机的通信问题**。它所包含的协议涉及数据包在整个网络上的逻辑传输，注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。  
IP协议是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务。

4. 数据链路层  
该层控制网络层与物理层之间的通信，其主要功能是**如何在不可靠的物理线路上进行数据的可靠传递**。为了保证传输，从网络层接收到的数据被分割成特定的可被物理层传输的帧。帧是用来移动数据的结构包，它不仅包括原始数据，还包括发送方和接收方的物理地址以及纠错和控制信息。其中的地址确定了帧将发送到何处，而纠错和控制信息则确保帧无差错到达。如果在传送数据时，接收点检测到所传数据中有差错，就要通知发送方重发这一帧。

5. 物理层  
该层负责比特流在节点间的传输，即**负责物理传输**。该层的协议既与链路有关，也与传输介质有关。 其通俗来讲就是把计算机连接起来的物理手段。

### TCP与UDP

TCP/UDP都属于传输层的协议，其区别在于：

- TCP是**面向连接**的传输层协议，**提供可靠服务**（传送的数据无差错，不丢失，不重复，且按序到达），但在建立、断开连接需要经历三次握手、四次挥手；主要用在对可靠性要求较高的地方。

- UDP是**无连接**的传输层协议，尽最大努力交付，即**不保证可靠交付**；主要用于实时性要求较高的场合如事实视频会议等。

### TCP的三次握手

<figure style="width: 50%" class="align-center">
    <img src="/assets/images/android/tcp-handshake.png">
    <figcaption>TCP流程</figcaption>
</figure>

几个名词

1. seq为Sequence Number
2. SYN为SYNchronize
3. ACK为ACKnowledge
4. FIN为FINish

SYN、ACK大写时为标志位，值为0或1；小写时表示序号。

TCP三次握手（SYN，SYN-ACK，ACK）：

1. 客户端向服务器端发送报文，报文中设置标志位`SYN=1`，生成随机序列号`seq=x`，此时客户端进入**SYN_SENT**状态
2. 服务端收到客户端的报文，由`SYN=1`可以知道客户端请求建立连接。服务端给客户端发送报文，设置标志位`SYN=1`，`ACK=1`，生成随机序列号`seq=y`，设置确认号`ack=x+1`，此时服务器端进入**SYN_RCVD**状态
3. 客户端接收到服务器的报文，检查`ACK`是否为1，`ack`是否为`x+1`。如果正确置`ACK=1`，`seq=x+1`，`ack=y+1`，并将该数据包发送给服务器端，服务器端检查`ACK`是否为1，`ack`是否为`y+1`。如果正确则连接建立成功，服务器端和客户端进入**ESTABLISHED**状态，完成三次握手

**为什么需要三次握手，两次确认？**  
为什么客户端还要发送一次确认呢，主要是为了防止已失效的连接请求报文突然又传送到了服务器端，造成错误。比如：客户端发送连接请求，因为网络或者一些其他因素造成没有在一定时间到达服务器端，所以客户端没有收到确认。于是客户端会重发一次连接请求，通过三次握手与服务器建立连接，但是这时上次的请求到达服务器端了，服务器会误以为客户端又发来了一次新的连接请求，会向客户端发送报文同意建立连接，但是客户端已经建立了，就会放弃掉该报文，服务器端没有收到响应，也就不会建立连接了。
{: .notice--info }

### TCP的四次挥手

四次挥手（FIN，ACK，FIN，ACK）：

1. 客户端发送报文，标志位`FIN=1`，`seq=n`，此时客户端进入到**FIN_WAIT_1**状态，表示客户端没有数据要发送给服务器
2. 服务端收到客户端发送的`FIN`报文，然后向客户端发送一个报文，设置标志位为`ACK=1`，确认序列号为`ack=n+1`，此时服务端进入**CLOSE_WAIT**状态.表示客户端到服务端的发送连接已经断开
3. 服务器发送报文到客户端，报文标志位`FIN=1`，`seq=m`，用来关闭服务器到客户端的数据传输，服务端进行**LAST_ACK**状态
4. 客户端收到服务器发送的标志位为`FIN`的报文，然后向服务器发送一个标志位为`ACK=1`的报文，确认序列号为`ack=m+1`，客户端进入到**TIME_WAIT**状态。等待`2MSL`（最大报文段生存时间）后依然没有收到回复，则说明服务端已正常关闭，这样客户端也可以关闭连接了

**为什么要等待2MSL**  
客户端发送的第4次握手报文，服务器没有收到。这时候服务器端会再次发送一个`FIN=1`的报文，而这个时候客户端还处于**CLIENT_WAIT**状态，所以可以再次发送确认消息。
{: .notice--info }