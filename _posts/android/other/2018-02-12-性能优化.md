---
title: "Android性能优化"
excerpt: "本文主要介绍一些Android的性能优化方法和程序设计的一些思想"
categories:
  - Android
tags:
 - ViewStub
 - include
 - merge
toc: true
toc_label: "目录"
last_modified_at: 2018-02-12T20:39:30+08:00
---

本章的主要内容包括
- 布局优化
- 绘制优化
- 内存优化
- 响应速度优化
- ListView优化
- Bitmap优化
- 线程优化等等

### 1 布局优化

1. **布局优化的思想就是尽量减少布局文件的层次。**  
   首先删除布局中无用的控件和层级。  
   其次有选择性的使用性能较低的`ViewGroup`，比如`RelativeLayout`。如果布局中既可以使用`LinearLayout`也可以使用`RelativeLayout`,那么就采用`LinearLayout`。这是因为`RelativeLayout`的功能比较复杂，它的布局过程需要话费更多的CPU时间。`FrameLayout`和`LinearLayout`一样都是一种简单高效的`ViewGroup`，因此可以考虑使用它们。但是很多时候无法单纯的通过一个`LinearLayout`或者`FrameLayout`无法实现产品效果，需要通过嵌套的方式来实现。这种情况还是建议采用`RelativeLayout`，因为`ViewGroup`的嵌套相当于增加了布局的层级，同样会降低程序的性能。  
  **可以考虑将**`RelativeLayout`**替换成**`ConstraintLayout`**，更加强大的布局方式，也足够扁平。**

2. **布局优化的外一种手段是采用**`include`、`merge`**标签和**`ViewStub`。  
   `include`标签主要用于布局重用，`merge`一般和`include`配合使用，它可以降低减少布局的层级，而`ViewStub`则提供了按需加载的功能，当需要时才会将`ViewStub`中的布局加载到内存，这样提高了程序的初始化效率。  
   `merge`标签一般和`include`标签一起使用从而减少布局的层级。比如，在一个竖直的线性布局中，如果被包含的布局文件中也采用竖直的`LinearLayout`，那么被包含的布局文件中的`LinearLayout`是多余的，通过`merge`标签就可以去掉多余的一层`LinearLayout`。  
   `ViewStub`继承至`View`，它非常轻量级且宽高都为0，因此它本身不参与任何的布局和绘制过程。`ViewStub`的意义在于按需加载所需的布局文件。比如网络异常时的界面，这个时候没有必要在整个界面初始化的时候将其加载进来，通过`ViewStub`就可以在使用的时候在加载，提高了程序初始化时的性能。  

   我们可以覆盖任何被include的布局的根布局的layout属性(`android:layout_*`)，当然我们必须指定`android:layout_width`和`android:layout_height`属性，这样其他覆盖的属性才会生效。
   {: .notice--success }

   下面是`ViewStub`的定义：  
   ```java
   <ViewStub
       android:id="@+id/stub_import"
       android:inflatedId="@+id/panel_import"
       android:layout="@layout/progress_overlay"
       android:layout_width="fill_parent"
       android:layout_height="wrap_content"
       android:layout_gravity="bottom" />
   ```
   其中`stub_import`是`ViewStub`的`id`，而`panel_import`就是`progress_overlay`这个布局文件根元素的`id`。  
   在加载`ViewStub`中的布局时，可以按照以下方式进行：  
   ```java
   findViewById(R.id.stub_import)).setVisibility(View.VISIBLE);
   // or
   View importPanel = ((ViewStub) findViewById(R.id.stub_import)).inflate();
   ```
   > **Note**: `inflate`方法会返回被填充的`View`，因此我们需要与此layout进行交互时，不需要在调用`findViewById`方法。
   
   一旦`ViewStub`调用上面的方法后，`ViewStub`会被替换掉，此时`ViewStub`不再是整个布局结构的一部分了。此外，`ViewStub`还不   支持`merge`标签。

### 2 绘制优化

绘制优化的分为两部分，一部分是避免过度绘制，另一部分指`View#onDraw`方法要避免执行大量的操作。

**`View#onDraw`方法优化：**

1. `onDraw`方法不要创建新的局部对象  
   Android Studio的lint有一项会检查此项：  
   Avoid object allocations during draw/layout operations (preallocate and reuse instead) less... (⌘F1)   
   Inspection info:You should avoid allocating objects during a drawing or layout operation. These are called frequently, so a smooth UI can be interrupted by garbage collection pauses caused by the object allocations.  The way this is generally handled is to allocate the needed objects up front and to reuse them for each drawing operation.  Some methods allocate memory on your behalf (such as Bitmap.create), and these should be handled in the same way.  
   Issue id: DrawAllocation
2. `onDraw`方法不要做耗时的任务，也不能执行成千上万次的循环操作。

> `View`的绘制帧率保证60fps最佳，这要求每帧的绘制时间不超过16ms(1000/60)。虽然程序很难保证16ms这个时间，但是尽量降低`onDraw`方法的复杂度总是切实有效的。

**避免过度绘制**

官方提供了一个修复过度绘制的一些要点：[Fix overdraw](https://developer.android.com/topic/performance/rendering/overdraw.html#fixing)，其中的内容有：

1. 减少布局中不必要的背景
2. 扁平view层级（这就是上面一节说到的布局优化了）
3. 减少透明度的使用  
   在屏幕上渲染透明像素（称为alpha渲染）是过度绘制的关键因素。与标准过度绘制不同，系统通过在现有绘制像素上方绘制多绘制一层不透明像素来完全隐藏现有绘制像素，透明对象需要首先绘制现有像素，以便可以出现正确的混合效果。透明动画、淡出和阴影等视觉效果都涉及某种透明度，因此对于过度绘制有着显著的影响。  
   您可以通过减少渲染的透明对象的数量来改善这些情况下的过度绘制。例如，您可以通过在TextView中绘制黑色文本并在其上设置半透明的alpha值来获取灰色文本。但是，通过简单地以灰色绘制文本，您可以获得相同的效果和更好的性能。

开发者模式中的一些设置可以在我们进行绘制优化时提供很大的帮助：[Inspect GPU rendering speed and overdraw](https://developer.android.com/studio/profile/inspect-gpu-rendering)，现以下面两节呈现。

#### 2.1 Profile GPU Rendering

Android 6.0（API Level 23）设备上Profile GPU Rendering图表示例如下：

<figure style="width: 50%" class="align-center">
    <img src="/assets/images/android/profile_gpu_rendering.png">
    <figcaption>Profile GPU Rendering 图表</figcaption>
</figure>

以下是有关输出的几点注意事项：  

- 对于每个可见应用，此工具将显示一个图表。
- 沿水平轴的每个竖条都代表一个帧，每个竖条的高度表示渲染该帧所花的时间（单位：毫秒）。
- 水平绿线表示 16 毫秒。 要实现每秒 60 帧，代表每个帧的竖条需要保持在此线以下。 当竖条超出此线时，可能会使动画出现暂停。
- 此工具通过加宽对应的竖条并降低透明度来突出显示超出 16 毫秒阈值的帧。
- 每个竖条都有与渲染管道中某个阶段对应的彩色区段。 区段数因设备的 API 级别而异。

下表介绍了使用运行 Android 6.0 及更高版本的设备时分析器输出中某个竖条的每个区段。

{% raw %}
<figcaption>Android 6.0 及更高版本中的竖条区段</figcaption>
<table>
  <thead>
    <tr>
      <th>竖条区段</th>
      <th>渲染阶段</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="background-color: #E47319"></td>
      <td>交换缓冲区</td>
      <td>表示 CPU 等待 GPU 完成其工作的时间。 如果此竖条升高，则表示应用在 GPU 上执行太多工作。</td>
    </tr>
    <tr>
      <td style="background-color: #D91e14"></td>
      <td>命令问题</td>
      <td>表示 Android 的 2D 渲染器向 OpenGL 发起绘制和重新绘制显示列表的命令所花的时间。 此竖条的高度与它执行每个显示列表所花的时间的总和成正比—显示列表越多，红色条就越高。</td>
    </tr>
    <tr>
      <td style="background-color: #5accf5"></td>
      <td>同步和上传</td>
      <td>表示将位图信息上传到 GPU 所花的时间。 大区段表示应用花费大量的时间加载大量图形。</td>
    </tr>
    <tr>
      <td style="background-color: #427af9"></td>
      <td>绘制</td>
      <td>表示用于创建和更新视图显示列表的时间。 如果竖条的此部分很高，则表明这里可能有许多自定义视图绘制，或 onDraw 函数执行的工作很多。</td>
    </tr>
    <tr>
      <td style="background-color: #34c3a9"></td>
      <td>测量/布局</td>
      <td>表示在视图层次结构中的 onLayout 和 onMeasure 回调上所花的时间。 大区段表示此视图层次结构正在花很长时间进行处理。</td>
    </tr>
    <tr>
      <td style="background-color: #0eb799"></td>
      <td>动画</td>
      <td>表示评估运行该帧的所有动画程序所花的时间。 如果此区段很大，则表示您的应用可能在使用性能欠佳的自定义动画程序，或因更新属性而导致一些意料之外的工作。</td>
    </tr>
    <tr>
      <td style="background-color: #0daa8e"></td>
      <td>输入处理</td>
      <td>表示应用执行输入 Event 回调中的代码所花的时间。 如果此区段很大，则表示此应用花太多时间处理用户输入。 考虑将此处理任务分流到另一个线程。</td>
    </tr>
    <tr>
      <td style="background-color: #08896d"></td>
      <td>其他时间/VSync延迟</td>
      <td>表示应用执行两个连续帧之间的操作所花的时间。 它可能表示界面线程中进行的处理太多，而这些处理任务本可以分流到其他线程。</td>
    </tr>
  </tbody>
</table>
{% endraw %}

4.0（API 级别 14）和 5.0（API 级别 21）之间的 Android 版本具有蓝色、紫色、红色和橙色区段。 低于 4.0 的 Android 版本只有蓝色、红色和橙色区段。 下表显示的是 Android 4.0 和 5.0 中的竖条区段。

{% raw %}
<figcaption>Android 4.0 及 5.0 中的竖条区段</figcaption>
<table>
  <thead>
    <tr>
      <th>竖条区段</th>
      <th>渲染阶段</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="background-color: #E47319"></td>
      <td>进程</td>
      <td>表示 CPU 等待 GPU 完成其工作的时间。 如果此竖条升高，则表示应用在 GPU 上执行太多工作。</td>
    </tr>
    <tr>
      <td style="background-color: #D91e14"></td>
      <td>执行</td>
      <td>表示 Android 的 2D 渲染器向 OpenGL 发起绘制和重新绘制显示列表的命令所花的时间。 此竖条的高度与它执行每个显示列表所花的时间的总和成正比—显示列表越多，红色条就越高。</td>
    </tr>
    <tr>
      <td style="background-color: #9900ff"></td>
      <td>XFer</td>
      <td>表示将位图信息上传到 GPU 所花的时间。 大区段表示应用花费大量的时间加载大量图形。 此区段在运行 Android 4.0 或更低版本的设备上不可见。</td>
    </tr>
    <tr>
      <td style="background-color: #427af9"></td>
      <td>更新</td>
      <td>表示用于创建和更新视图显示列表的时间。 如果竖条的此部分很高，则表明这里可能有许多自定义视图绘制，或 onDraw 函数执行的工作很多。</td>
    </tr>
  </tbody>
</table>
{% endraw %}

**注：** 尽管此工具名为 Profile GPU Rendering，但所有受监控的进程实际上发生在 CPU 中。 通过将命令提交到 GPU 触发渲染，GPU 异步渲染屏幕。 在某些情况下，GPU 会有太多工作要处理，在它可以提交新命令前，您的 CPU 必须等待。 在等待时，您将看到橙色条和红色条中出现峰值，且命令提交将被阻止，直到 GPU 命令队列腾出更多空间。
{: .notice--info }

#### 2.2 Debug GPU Overdraw

当应用在同一帧中多次绘制相同像素时，便会发生过度绘制。  

Android 按如下方法为界面元素设置颜色，以便确定过度绘制的次数：

- **True color**：没有过度绘制
- <img src="/assets/images/android/overdraw-blue.png" style="border: none">**蓝色**：过度绘制1次
- <img src="/assets/images/android/overdraw-green.png" style="border: none">**绿色**：过度绘制2次
- <img src="/assets/images/android/overdraw-pink.png" style="border: none">**粉色**：过度绘制3次
- <img src="/assets/images/android/overdraw-red.png" style="border: none">**红色**：过度绘制4次及以上

<figure style="width: 50%" class="align-center">
    <img src="/assets/images/android/gpu-overdraw-before.png">
    <figcaption>某个应用正常时的样子（左侧），以及它在 GPU 过度绘制后的样子（右侧）</figcaption>
</figure>

<figure style="width: 50%" class="align-center">
    <img src="/assets/images/android/gpu-overdraw-after.png">
    <figcaption>大量过度绘制的应用（左侧）以及很少过度绘制的应用（右侧）的示例</figcaption>
</figure>

请记住，有些过度绘制是不可避免的。在优化您的应用的界面时，应尝试达到大部分显示true color或仅有 1 次过度绘制（蓝色）的视觉效果。

### 3 内存优化

内存优化一方面避免发生内存泄漏([JVM基础知识](/jvm/jvm-content/))，一方面注意内存的管理([Manage your app's memory](https://developer.android.com/topic/performance/memory))。

#### 3.1 常见内存泄漏

造成内存泄漏的根本原因是生命周期较短的某个对象被生命周期更长的对象所持有，导致该对象不能及时释放。

> **Leak Canary检测内存泄漏原理**：  
> 在Activity destroy后将Activity的弱引用关联到ReferenceQueue中，这样Activity GC之后会出现在ReferenceQueue中。  
> 随后，会向主线程的MessageQueue添加一个`IdleHandler`，用于在idle时触发一个发生在HandlerThread的等待5秒后开始检测内存泄漏的代码。  
> 首先会判断是否对象已经被回收，如果有，则没有内存泄漏，结束；否则，调用`Runtime.getRuntime().gc()`进行GC，等待100ms后再次判断是否已经被GC，若还没有被回收，那么说明有内存泄漏，开始dump hprof。

注意一下静态匿名内部类和非静态匿名内部类的区别，一句话总结：**非静态匿名内部类会持有外部class的强引用**。这就是Handler需要使用static修饰，且持有Activity时需要持有WeakReference的缘故。*看Handler写的业务代码的时候很烦，往往msg还是诸如0、1这样的魔法值，还要在Handler实现的位置与发送的位置之间互相转换，实在令人头疼。吹爆RxJava，只从学了RxJava，写复杂一点的逻辑真是越来越轻松了，可读性还好*

<figcaption>静态匿名内部类和非静态匿名内部类的区别</figcaption>

| | static inner class | non static inner class |
| -- | --------------- | ---------------------- |
| 与外部class引用关系 | 没有引用关系 | 自动获得强引用 |
| 被调用时需要外部实例 | 不需要      | 需要         |
| 能否调用外部class中的变量和方法 | 不能  | 能      |
| 生命周期           | 自主的生命周期 | 依赖于外部累，甚至比外部类更长 |


##### 3.1.1 静态变量导致的内存泄漏

因为静态变量生命周期等于应用程序的生命周期，所以静态变量引用的变量不会被回收掉。这里涉及到[GC Roots](/jvm/java-gc/#322-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95)的概念。  

下面是两种明显的内存泄漏：
```java
public class MyCouponActivity extends BaseActivity  {

    private static Context sContext;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_my_coupon);
        sContext = this;
    }
}

// or

public class MyCouponActivity extends BaseActivity  {

    private static View sView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_my_coupon);
        sView = new View(this);
    }
}
```

这种内存泄漏，Android Studio会有提示：  
![memory_leak_static]({{ basepath }}/assets/images/android/memory_leak_static.png)

##### 3.1.2 单例模式导致的内存泄漏

首先提供一个单例模式，可以接受外部的注册并将外部监听器保存起来。

```java
public class TestManager {
    public interface OnDataArrivedListener {
        void onDataArrived(Object data);
    }

    private List<OnDataArrivedListener> mOnDataArrivedListeners = new ArrayList<>();

    private static class SingletonHolder {
        public static final TestManager INSTANCE = new TestManager();
    }

    private TestManager() {}

    public static TestManager getInstance() {
        return SingletonHolder.INSTANCE;
    }

    public synchronized void registerListener(OnDataArrivedListener listener) {
        if (!mOnDataArrivedListeners.contains(listener)) {
            mOnDataArrivedListeners.add(listener);
        }
    }

    public synchronized void unregisterListener(OnDataArrivedListener listener) {
        mOnDataArrivedListeners.remove(listener);
    }
}
```
然后让`Activity`实现`OnDataArrivedListener`接口并向`TestManager`注册监听。下面的代码由于缺少解注册所以会引起内存泄漏，这是因为`Activity`的对象被单例模式所持有，而单例模式的生命周期和`Application`保持一致，因此`Activity`无法被及时释放。
```java
public class AppWidgetActivity extends ActivityBase implements TestManager.OnDataArrivedListener{

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_app_widget);
        TestManager.getInstance().registerListener(this);
    }

    @Override
    public void onDataArrived(Object data) {}
}
```

##### 3.1.3 其他情况造成的内存泄漏

1. 属性动画导致的内存泄漏  
   属性动画中有一类无限循环的动画，如果`Activity`中播放此类动画且没有在`onDestory`方法中去停止动画，那么动画会一直播放下去。我们需要在`Activity#onDestory`中调用`animator.cancel()`方法来停止动画。
2. 网络、文件等流忘记关闭
3. 手动注册广播时，退出时忘记`unregisterReceiver()`
4. Service执行完后忘记`stopSelf()`
5. EventBus等观察者模式的框架忘记手动解除注册

#### 3.2 内存管理

内存管理可以看[Manage your app's memory](https://developer.android.com/topic/performance/memory)

实现`ComponentCallbacks2`接口，根据`onTrimMemory`中的level做出不同的响应。

```kotlin
import android.content.ComponentCallbacks2
// Other import statements ...

class MainActivity : AppCompatActivity(), ComponentCallbacks2 {

    // Other activity code ...

    /**
     * Release memory when the UI becomes hidden or when system resources become low.
     * @param level the memory-related event that was raised.
     */
    override fun onTrimMemory(level: Int) {

        // Determine which lifecycle or system event was raised.
        when (level) {

            ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN -> {
                /*
                   Release any UI objects that currently hold memory.

                   The user interface has moved to the background.
                */
            }

            ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE,
            ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW,
            ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL -> {
                /*
                   Release any memory that your app doesn't need to run.

                   The device is running low on memory while the app is running.
                   The event raised indicates the severity of the memory-related event.
                   If the event is TRIM_MEMORY_RUNNING_CRITICAL, then the system will
                   begin killing background processes.
                */
            }

            ComponentCallbacks2.TRIM_MEMORY_BACKGROUND,
            ComponentCallbacks2.TRIM_MEMORY_MODERATE,
            ComponentCallbacks2.TRIM_MEMORY_COMPLETE -> {
                /*
                   Release as much memory as the process can.

                   The app is on the LRU list and the system is running low on memory.
                   The event raised indicates where the app sits within the LRU list.
                   If the event is TRIM_MEMORY_COMPLETE, the process will be one of
                   the first to be terminated.
                */
            }

            else -> {
                /*
                  Release any non-critical data structures.

                  The app received an unrecognized memory level value
                  from the system. Treat this as a generic low-memory message.
                */
            }
        }
    }
}
```

### 4 响应速度优化

响应速度优化的核心思想是**避免在主线程中做耗时操作**，常见的就是IO操作以及计算量大的操作等。  

另外，优化App启动时间也是一种学问，详见[App startup time](https://developer.android.com/topic/performance/vitals/launch-time)。  
App启动可以分为三种情况：冷启动(cold start)、温启动(warm start)、热启动(hot start)。

### 5 ListView和Bitmap优化

`ListView`和`GridView`的优化主要分为三个方面：
1. 要采用`ViewHolder`并避免在`getView`中执行耗时操作。
2. 根据列表的滑动状态来控制任务的执行频率，如当列表快速滑动时显然不太适合开启大量的异步任务。
3. 可以尝试开启硬件加速来使`ListView`的滑动更加流畅。

`Bitmap`的优化主要是通过`BitmapFactory.Options`来根据需要对图片进行采样，采样过程主要采用到了`BitmapFactory.Options#inSampleSize`参数。

### 6 线程优化
线程优化的思想是采用线程池，避免在程序中使用大量的`Thread`。可以考虑使用线程池。

### 7 一些性能优化建议
1. 避免创建过多的对象
2. 不要过多使用枚举，枚举占用的内存控件比整型大
3. 常量请使用`static final`修饰
4. 使用Android特有的数据结构，比如`SparseArray`和`Pair`等，它们具有更好的性能
5. 适当使用软应用和弱应用
6. 采用内存缓存和磁盘缓存
7. 尽量采用静态内部类，这样可以避免潜在的由于内部类导致的内存泄漏。
