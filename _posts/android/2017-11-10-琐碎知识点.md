---
excerpt: "记录一下博主遇到的琐碎的知识点，方便查找"
categories:
  - Android
tags:
  - CopyOnWriteArrayList
  - RemoteCallbackList
  - windowSoftInputMode
  - SoftInput
  - Sort
  - Comparator
  - Dial
  - Call
  - SMS
  - drawable
  - Response
  - Font
  - CountDownLatch
  - CountDownTimer
---

CopyOnWriteArrayList支持并发读写。

---

RemoteCallbackList支持跨进程删除listener，原理是`ArrayMap<IBinder, Callback>`。IPC时Parcelable对象会序列化、反序列化，因此不会是同一个对象，但底层IBinder不会变。
它同时具有以下特点：
1. 客户端进程终止后，能够自动移除客户端注册的listener
2. RemoteCallbackList内部自动实现了线程同步功能，所以使用它来进行注册、解注册时不需要做额外的线程同步工作。

---

EditText禁止进入时弹出键盘：
```xml
android:windowSoftInputMode="stateHidden"
```
键盘弹出时禁止顶动View：
```xml
android:windowSoftInputMode="adjustPan"
```

---

跳转拨号盘
```java
new Intent(Intent.ACTION_DIAL, Uri.parse("tel:12306"));
```
直接拨打电话
```java
new Intent(Intent.ACTION_CALL, Uri.parse("tel:12306"));
```
发送短信
```java
new Intent(Intent.ACTION_SENDTO, Uri.parse("smsto:12306"));
```

---

Java Bean实体进行排序
```java
Collections.sort(mRowsBeanList, new Number2zComparator());

private class Number2zComparator implements Comparator<T> {
    @Override
    public int compare(T o1, T o2) {
        boolean o1IsHot = o1.getHotFlag() == 1;
        boolean o2IsHot = o2.getHotFlag() == 1;
        String o1Letter = PinyinUtils.ccs2Pinyin(o1.getPlatformName());
        String o2Letter = PinyinUtils.ccs2Pinyin(o2.getPlatformName());

        if (o1IsHot && o2IsHot) {
            return o1Letter.compareToIgnoreCase(o2Letter);
        } else if (o1IsHot) {
            return -1;
        } else if (o2IsHot) {
            return 1;
        }

        return o1Letter.compareToIgnoreCase(o2Letter);
    }
}
```
o1与o2进行比较，如果o1要排在o2前面，返回-1;  
如果两者相等，返回0;  
如果o1排在o2后面，返回1。

---

Gif加载  
在尝试Glide加载(不卡，但是图片错乱了)、帧动画实现(超级耗内存，30帧，每帧8k原图，耗内存大约20M)、android-gif-drawable库(Android O异常卡顿，耗内存大约10M)加载失败之后，找到了一种新奇的思路：每隔一段时间调用`setBackgroundResource`，内存消耗基本不计。

---

代码设置drawable：  
setCompoundDrawablesWithIntrinsicBounds

---

OkHttp访问网络成功的回调中，`Response response`的response.body().string()只能调用一次，否则
```java
E/AndroidRuntime: FATAL EXCEPTION: OkHttp Dispatcher
                  Process: yorek.demoandtest, PID: 24671
                  java.lang.IllegalStateException: closed
```

---

Glide加载圆形图片

```java
Glide.with(mContext)
    .load(item.platformLogo)
    .bitmapTransform(CropCircleTransformation(mContext))
    .into(iv_logo)
```

其中，`.bitmapTransform(CropCircleTransformation(mContext))`是其中的重点，
`CropCircleTransformation`使用了`jp.wasabeef:glide-transformations:2.0.2`这个lib

```
compile 'jp.wasabeef:glide-transformations:2.0.2'
```
---

`SwipeRefreshLayout`与`CollapsingToolbarLayout`和充满`RecyclerView`的`ViewPager`联用出现的滑动冲突问题

解决办法是自定义`SwipeRefreshLayout`，在`AppBarLayout`元素没有到顶时允许child向上滑，到顶后不允许滑动，这样就触发了下拉刷新。

```java
public class CreditFragmentSwipeRefreshLayout extends SwipeRefreshLayout {
    private AppBarLayout targetView;

    public CreditFragmentSwipeRefreshLayout(Context context) {
        super(context);
    }

    public CreditFragmentSwipeRefreshLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        targetView = (AppBarLayout) findViewById(R.id.abl);
    }

    @Override
    public boolean canChildScrollUp() {
        if (targetView != null) {
            return targetView.getTop() != 0;
        } else {
            return super.canChildScrollUp();
        }
    }
}
```

---
Android中字体的加载

在`app/src/main/assets`下面放置字体文件，然后使用下面的代码加载    
```kotlin
class KTypeface {
    companion object {
        val DIN_PRO_MIDIUM =
            Typeface.createFromAsset(MyApp.getInstance().assets, "DINPro-Medium.otf")
        val ROBOTO_MIDIUM =
            Typeface.createFromAsset(MyApp.getInstance().assets, "Roboto-Medium.ttf")
    }
}
```

这么使用：  
```kotlin
tvMyScore.typeface = KTypeface.DIN_PRO_MIDIUM
```

Android中字体最好加载一次之后缓存起来，因为每次加载需要消耗时间。

---
`CountDownLatch`与`CountDownTimer`  

`CountDownLatch`是用来实现线程同步的一个工具。其主要有一下三个方法  
1. `public CountDownLatch(int count)`  
  初始化计数器
2.  `public void await() throws InterruptedException`  
  堵塞线程，直到计数器为0
3.  `public void countDown()`  
  计数，表示执行完成。没调用一次，计数器会减1



`CountDownTimer`是一种用来实现倒计时的手段，其用法如下:  

```java
timer = new CountDownTimer(count * 1000, 1000) {
    @Override
    public void onTick(long millisUntilFinished) {
        tvGetcode.setText(((millisUntilFinished / 1000) + "秒后重发"));
    }

    @Override
    public void onFinish() {
        tvGetcode.setEnabled(true);
        tvGetcode.setText("获取验证码");
    }
};
timer.start();
```

如上，创建之后调用`start`方法开始计数，每隔一段(第二个参数)就会调用`onTick`方法，在这里更新倒计时，最后会调用`onFinish`方法，这里进行倒计时完成的操作。  
当然`CountDownTimer`也是有`cancel`来取消倒计时的。

不过，在实践中发现这种倒计时方式`onTick`报时不太准，因为这依赖于底层的`Handler`来执行操作。
