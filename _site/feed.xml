<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-12-18T23:04:44+08:00</updated><id>http://localhost:4000/</id><title type="html">Yorek’s Blog</title><subtitle>An Android Developer.</subtitle><author><name>刘扬窑Yorek</name></author><entry><title type="html">Android四大组件(4)</title><link href="http://localhost:4000/android%20sdk/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6(4)/" rel="alternate" type="text/html" title="Android四大组件(4)" /><published>2017-12-18T00:00:00+08:00</published><updated>2017-12-18T00:00:00+08:00</updated><id>http://localhost:4000/android%20sdk/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6(4)</id><content type="html" xml:base="http://localhost:4000/android%20sdk/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6(4)/">&lt;p&gt;本章的主要内容是&lt;a href=&quot;https://developer.android.com/guide/topics/providers/content-providers.html&quot;&gt;Content Providers&lt;/a&gt;以及&lt;a href=&quot;https://developer.android.com/guide/components/fragments.html&quot;&gt;Fragment&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;ContentProvider可以帮助应用程序管理自身存储的数据，并提供了一种与其他应用程序共享数据的方式。它们封装数据，并提供数据安全的机制。ContentProvider是代码运行的进程与另一个进程连接数据的标准接口。实现ContentProvider有很多优点。更重要的是，你可以配置一个ContentProvider，以允许其他应用程序能够安全地访问和修改应用程序数据，如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2525608-03233404671ddf53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;content-provider-overview.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;系统预置了很多ContentProvider，比如MediaProvider、CalendarProvider、ContactsProvider等等，要跨进程访问这些信息，只需要通过ContentProvider的query、update、insert和delete方法即可。而创建一个ContentProvider也很简单，只需要实现onCreate、query、update、insert、delete和getType。onCreate可以做一些初始化工作，getType用来返回一个URI请求所对应的mimeType，如果应用不关注这个，可以返回null或者”*/*“。剩下的四个方法对应CRUD操作。
根据Binder的工作原理，除了onCreate由系统回调运行在主线程中，其他五个方法运行在Binder线程池中。&lt;/p&gt;

&lt;h2 id=&quot;1-自定义contentprovider&quot;&gt;1 自定义ContentProvider&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;ContentProvider的注册
```xml
 &amp;lt;provider android:authorities=”list”
       android:directBootAware=[“true” | “false”]
       android:enabled=[“true” | “false”]
       android:exported=[“true” | “false”]
       android:grantUriPermissions=[“true” | “false”]
       android:icon=”drawable resource”
       android:initOrder=”integer”
       android:label=”string resource”
       android:multiprocess=[“true” | “false”]
       android:name=”string”
       android:permission=”string”
       android:process=”string”
       android:readPermission=”string”
       android:syncable=[“true” | “false”]
       android:writePermission=”string” &amp;gt;
 . . .&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;lt;/provider&amp;gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;- android:authorities
ContentProvider唯一授权码，通过这个可以访问此Provider。另外该字串必须唯一，因此建议加上包名。
- android:name
 实现了ContentProvider的类名，指注册那个Provider。
- Permissions
有如下几种权限
  - android:grantUriPermssions: 临时权限标记
  - android:permission: 单个Provider范围读写权限
  - android:readPermission: Provider范围读权限
  - android:writePermission: Provider范围写权限
- 启动和控制属性
  这些属性决定了Android系统如何以及何时启动Provider，Provider的进程特性以及其他运行时设置：
  - android:enabled: 是否允许系统启动provider
  - android:exported: 是否允许其他应用启动provider
  - android:initOrder: 相对于同一进程中的其他提供者，应该启动此provider的顺序。
  - android:multiProcess: 允许系统在与调用客户端相同的进程中启动Provider。
  - android:process: Provider应该运行的进程名。
  - android:syncable: Provider的数据要与服务端数据同步。
- 信息化属性
  可以选择设置provider的图标和名称
  - android:icon: provider的图标. 图标的显示紧挨着Provider的名称，可以在Settings &amp;gt; Apps &amp;gt; All中查看。
  - android:label: 可显示Provider或者其数据或者两者的描述信息的文本，可以在Settings &amp;gt; Apps &amp;gt; All中查看。

完整文档可以查看[&amp;lt;provider&amp;gt;](https://developer.android.com/guide/topics/manifest/provider-element.html)

2. ContentProvider的实现
ContentProvider通过URI来区分外界要访问的数据集合，为了更好的知道URI对应的是什么表、什么字段，我们可以使用`UriMatcher`来简化操作。
该办法的原理就是在addURI方法中将`authority`与`path`组合，然后等match时与传入的URI比较。如果相等则返回`code`。 
```java
public class LocalProvider extends ContentProvider {
    private static final String TAG = &quot;LocalProvider&quot;;

    private SQLiteOpenHelper mOpenHelper;

    private static final int DATA = 1;
    private static final int DATA_ID = 2;
    private static final UriMatcher sURLMatcher = new UriMatcher(
            UriMatcher.NO_MATCH);

    static {
        sURLMatcher.addURI(&quot;*&quot;, &quot;data&quot;, DATA);
        sURLMatcher.addURI(&quot;*&quot;, &quot;data/#&quot;, DATA_ID);
    }

    private static class DatabaseHelper extends SQLiteOpenHelper {
        private static final String DATABASE_NAME = &quot;local.db&quot;;
        private static final int DATABASE_VERSION = 1;

        public DatabaseHelper(Context context) {
            super(context, DATABASE_NAME, null, DATABASE_VERSION);
        }

        @Override
        public void onCreate(SQLiteDatabase db) {
            db.execSQL(&quot;CREATE TABLE data (&quot; +
                       &quot;_id INTEGER PRIMARY KEY,&quot; +
                       &quot;text TEXT, &quot; +
                       &quot;integer INTEGER);&quot;);

            // insert alarms
            db.execSQL(&quot;INSERT INTO data (text, integer) VALUES ('first data', 100);&quot;);
        }

        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int currentVersion) {
            Log.w(TAG, &quot;Upgrading test database from version &quot; +
                  oldVersion + &quot; to &quot; + currentVersion +
                  &quot;, which will destroy all old data&quot;);
            db.execSQL(&quot;DROP TABLE IF EXISTS data&quot;);
            onCreate(db);
        }
    }

    public LocalProvider() {
    }

    @Override
    public boolean onCreate() {
        mOpenHelper = new DatabaseHelper(getContext());
        return true;
    }

    @Override
    public Cursor query(Uri url, String[] projectionIn, String selection,
            String[] selectionArgs, String sort) {
        SQLiteQueryBuilder qb = new SQLiteQueryBuilder();

        // Generate the body of the query
        int match = sURLMatcher.match(url);
        switch (match) {
            case DATA:
                qb.setTables(&quot;data&quot;);
                break;
            case DATA_ID:
                qb.setTables(&quot;data&quot;);
                qb.appendWhere(&quot;_id=&quot;);
                qb.appendWhere(url.getPathSegments().get(1));
                break;
            default:
                throw new IllegalArgumentException(&quot;Unknown URL &quot; + url);
        }

        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
        Cursor ret = qb.query(db, projectionIn, selection, selectionArgs,
                              null, null, sort);

        if (ret == null) {
            if (false) Log.d(TAG, &quot;Alarms.query: failed&quot;);
        } else {
            ret.setNotificationUri(getContext().getContentResolver(), url);
        }

        return ret;
    }

    @Override
    public String getType(Uri url) {
        int match = sURLMatcher.match(url);
        switch (match) {
            case DATA:
                return &quot;vnd.android.cursor.dir/vnd.google.unit_tests.local&quot;;
            case DATA_ID:
                return &quot;vnd.android.cursor.item/vnd.google.unit_tests.local&quot;;
            default:
                throw new IllegalArgumentException(&quot;Unknown URL&quot;);
        }
    }

    @Override
    public int update(Uri url, ContentValues values, String where, String[] whereArgs) {
        int count;
        long rowId = 0;
        int match = sURLMatcher.match(url);
        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
        switch (match) {
            case DATA_ID: {
                String segment = url.getPathSegments().get(1);
                rowId = Long.parseLong(segment);
                count = db.update(&quot;data&quot;, values, &quot;_id=&quot; + rowId, null);
                break;
            }
            default: {
                throw new UnsupportedOperationException(
                        &quot;Cannot update URL: &quot; + url);
            }
        }
        if (false) Log.d(TAG, &quot;*** notifyChange() rowId: &quot; + rowId);
        getContext().getContentResolver().notifyChange(url, null);
        return count;
    }


    @Override
    public Uri insert(Uri url, ContentValues initialValues) {
        return null;
    }

    @Override
    public int delete(Uri url, String where, String[] whereArgs) {
        throw new UnsupportedOperationException(&quot;delete not supported&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; 值得注意的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;insert&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;delete&lt;/code&gt;方法会引起数据源的改变，此时需要通过ContentResolver的notifyChange方法通知当前ContentProvider中的数据已经发生了变化。
要观察ContentProvider的数据改变情况，可以通过ContentResolver的&lt;code class=&quot;highlighter-rouge&quot;&gt;registerContentObserver&lt;/code&gt;方法来注册观察，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;unregisterContentObserver&lt;/code&gt;来解除观察。
上面已经提到过，除了onCreate之外的其他五个方法都是运行在Binder线程池中，&lt;strong&gt;因此CRUD四大方法是存在多线程并发访问的。但是SQLiteDatabase内部对数据库的操作是有同步处理的，因此此时无需考虑线程同步问题。但是多个SQLiteDatabase同时操作数据库就无法保证线程同步了。如果ContentProvider底层的数据集是一块内存(比如List)，此时就要进行数据同步处理。&lt;/strong&gt;
ContentProvider除了支持对数据源的增删改查操作外，还支持自定义的Call方法，这个过程可以通过ContentProvider的Call方法和ContentResolver的Call方法来完成。&lt;/p&gt;

&lt;h2 id=&quot;2-fragment&quot;&gt;2 Fragment&lt;/h2&gt;
&lt;p&gt;Fragment表示Activity中的部分行为或者UI。我们可以将多个framgent组合进一个Activity来构建一个多窗格的UI，一个fragment也能在多个Activity中进行复用。我们可以将fragment理解为Activity的一个模块，它有自己的生命周期，接收自己的输入事件，我们可以在Activity运行时添加或者删除一个fragment。
Fragment必须嵌入到Activity中，且其生命周期会直接被宿主Activity的生命周期影响。&lt;/p&gt;

&lt;h3 id=&quot;21-fragment的创建&quot;&gt;2.1 Fragment的创建&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2525608-4777a686caeb3c4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;fragment_lifecycle.png&quot; /&gt;
通常我们至少需要实现以下生命周期方法：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;onCreate()
创建Fragment时调用。我们应该初始化Fragment暂停或停止，然后恢复时要保留的必要组件。&lt;/li&gt;
  &lt;li&gt;onCreateView()
第一次绘制UI时调用。我们在这里要返回fragment布局的根view，如果Fragment不提供UI，可以返回null。&lt;/li&gt;
  &lt;li&gt;onPause()
用户正在离开fragment时调用，这并不总是意味着Fragment正在被销毁。我们应该在这里提供需要持久化的用户的更改操作，因为用户可能不再回来。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-添加layout&quot;&gt;2.2 添加layout&lt;/h3&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ExampleFragment&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Fragment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;View&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onCreateView&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LayoutInflater&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inflater&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ViewGroup&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                             &lt;span class=&quot;n&quot;&gt;Bundle&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Inflate the layout for this fragment&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inflater&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;inflate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;example_fragment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;inflate&lt;/code&gt;方法有三个参数：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;待填充的layout的id&lt;/li&gt;
  &lt;li&gt;一个被填充layout的parent的ViewGroup&lt;/li&gt;
  &lt;li&gt;填充时被填充layout是否被添加到第二个参数上。此处用false因为系统已经处理了，如果传递true将会导致冗余。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;23-将fragment添加至activity&quot;&gt;2.3 将Fragment添加至Activity&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;在Activity的layout中声明fragment
```java
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;horizontal&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt;
    &lt;fragment android:name=&quot;com.example.news.ArticleListFragment&quot; android:id=&quot;@+id/list&quot; android:layout_weight=&quot;1&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; /&gt;
    &lt;fragment android:name=&quot;com.example.news.ArticleReaderFragment&quot; android:id=&quot;@+id/viewer&quot; android:layout_weight=&quot;2&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; /&gt;
&lt;/LinearLayout&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;2. 代码添加Fragment到已存在的ViewGroup中
```java
FragmentManager fragmentManager = getFragmentManager();
FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();

ExampleFragment fragment = new ExampleFragment();
fragmentTransaction.add(R.id.fragment_container, fragment);
fragmentTransaction.commit();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;添加没有UI界面的Fragment&lt;/strong&gt;
有时我们也想为Activity添加一个后台运行的Fragment，此时可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;fragmentTransaction.add(Fragment, String)&lt;/code&gt;，提供一个唯一的String作为tag，而不是布局的id。可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;fragmentManager.findFragmentByTag()&lt;/code&gt;获取Fragment。&lt;/p&gt;

&lt;h3 id=&quot;24-管理fragment&quot;&gt;2.4 管理Fragment&lt;/h3&gt;
&lt;p&gt;我们可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;FragmentManager&lt;/code&gt;管理Fragment。在Activity中使用&lt;code class=&quot;highlighter-rouge&quot;&gt;getFragmentManager()&lt;/code&gt;来获取它。
&lt;code class=&quot;highlighter-rouge&quot;&gt;FragmentManager&lt;/code&gt;可以做以下事情：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;从Activity中获取已存在的Fragment，&lt;code class=&quot;highlighter-rouge&quot;&gt;findFragmentById()&lt;/code&gt;获取有UI的，&lt;code class=&quot;highlighter-rouge&quot;&gt;findFragmentByTag()&lt;/code&gt;获取没有UI的。&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;popBackStack()&lt;/code&gt;（模拟用户的Back命令）从返回栈中弹出Fragment。&lt;/li&gt;
  &lt;li&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;addOnBackStackChangedListener()&lt;/code&gt;注册一个监听器监听返回栈的更改。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;25-执行fragmenttransaction&quot;&gt;2.5 执行FragmentTransaction&lt;/h3&gt;
&lt;p&gt;FragmentTransaction可以执行add、remove、replace，完成后执行commit生效。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Create new fragment and transaction&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Fragment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newFragment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ExampleFragment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;FragmentTransaction&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getFragmentManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;beginTransaction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Replace whatever is in the fragment_container view with this fragment,&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// and add the transaction to the back stack&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;replace&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;fragment_container&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newFragment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;addToBackStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Commit the transaction&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;transaction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;commit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;addToBackStack()&lt;/code&gt;，替换的事务将保存到返回栈，以便用户可以通过按Back按钮来反转事务并返回上一个Fragment。
为了从返回栈中取回碎片，必须在Activity中重写&lt;code class=&quot;highlighter-rouge&quot;&gt;onBackPressed()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onBackPressed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getFragmentManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBackStackEntryCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;getFragmentManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;popBackStack&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onBackPressed&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果不重写该方法，会导致不能回退Fragment。
如果在一个事务提交中操作了多次，这多次操作将会作为一个独立的事务提交，如果回退事务，这些事务将会一起回退。
在我们remove一个Fragment时，如果没有调用&lt;code class=&quot;highlighter-rouge&quot;&gt;addToBackStack()&lt;/code&gt;，Fragment将会被销毁；如果调用了，Fragment将会stopped。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;提示：对于每个Fragment的事务，在提交之前可以调用&lt;code class=&quot;highlighter-rouge&quot;&gt;setTransition()&lt;/code&gt;来应用转场动画。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;commit()&lt;/code&gt;并不会立刻执行事务。当主线程能够执行时，会按照顺序执行。如果有必要，可以在主线程调用&lt;code class=&quot;highlighter-rouge&quot;&gt;executePendingTransactions()&lt;/code&gt;来立刻执行通过&lt;code class=&quot;highlighter-rouge&quot;&gt;commit()&lt;/code&gt;提交的事务。除非事务依赖于其他线程的作业，一般不需要这么做。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：只有在Activity保存状态（用户离开Activity）之前，才可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;commit()&lt;/code&gt;提交事务。 如果您尝试在此之后提交，将抛出异常。 这是因为如果活动需要恢复，则提交后的状态可能会丢失。 对于丢失提交的情况如果OK的话，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;commitAllowingStateLoss()&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;26-与activity通信&quot;&gt;2.6 与Activity通信&lt;/h3&gt;
&lt;p&gt;Fragment中可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;getActivity()&lt;/code&gt;获取Activity的实例。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;View&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;listView&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findViewById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在Activity中可以使用FragmentManager的&lt;code class=&quot;highlighter-rouge&quot;&gt;findFragmentById()&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;findFragmentByTag()&lt;/code&gt;获取Fragment实例。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ExampleFragment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fragment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ExampleFragment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getFragmentManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;findFragmentById&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;example_fragment&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;261-创建与activity的事件回调&quot;&gt;2.6.1 创建与Activity的事件回调&lt;/h4&gt;
&lt;p&gt;可以在Fragment中声明一个回调接口，宿主Activity必须实现该接口。为了保证宿主Activity实现了该接口，可以在Fragment的&lt;code class=&quot;highlighter-rouge&quot;&gt;onAttach(Activity)&lt;/code&gt;中将宿主Activity进行强制类型转换，若宿主Activity没有实现该接口，则会抛出错误。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;FragmentA&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ListFragment&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;OnArticleSelectedListener&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// Container Activity must implement this interface&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OnArticleSelectedListener&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onArticleSelected&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Uri&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;articleUri&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onAttach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Activity&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;onAttach&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mListener&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OnArticleSelectedListener&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClassCastException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ClassCastException&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;activity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;toString&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; must implement OnArticleSelectedListener&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;262-给app-bar添加item&quot;&gt;2.6.2 给App bar添加Item&lt;/h4&gt;
&lt;p&gt;Fragment通过实现&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreateOptionsMenu()&lt;/code&gt;可以给Activity添加菜单项。但是，为了使该方法能够接受调用，我们必须在&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;期间调用&lt;code class=&quot;highlighter-rouge&quot;&gt;setHasOptionsMenu()&lt;/code&gt;，该方法表明Fragment将会为Activity添加菜单项；否则，Fragment不会接受&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreateOptionsMenu()&lt;/code&gt;方法的调用。
我们从Fragment中添加到选项菜单中的菜单项都会附加到已存在的菜单项中。Fragment在菜单项被选中时也能接受&lt;code class=&quot;highlighter-rouge&quot;&gt;onOptionsItemSelected()&lt;/code&gt;回调。
在Fragment中也能使用&lt;code class=&quot;highlighter-rouge&quot;&gt;registerForContextMenu()&lt;/code&gt;为View注册上下文菜单。当用户打开上下文菜单时，Fragment会接受到&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreateContextMenu()&lt;/code&gt;方法的调用。当用户选择一个菜单时，Fragment会接受到&lt;code class=&quot;highlighter-rouge&quot;&gt;onContextItemSelected()&lt;/code&gt;的回调。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 虽然Fragment会接受到每一个由它添加的菜单的on-item-selected回调，但是宿主Activity首先会接受到这些回调。如果Activity实现的on-item-selected回调方法没有处理这些菜单项，那么事件会被传递到Fragment的回调。这对于选项菜单和上下文菜单都适用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For more information about menus, see the &lt;a href=&quot;https://developer.android.com/guide/topics/ui/menus.html&quot;&gt;Menus&lt;/a&gt; developer guide and the &lt;a href=&quot;https://developer.android.com/training/appbar/index.html&quot;&gt;App Bar&lt;/a&gt; training class.&lt;/p&gt;

&lt;h3 id=&quot;27-处理fragment的生命周期&quot;&gt;2.7 处理Fragment的生命周期&lt;/h3&gt;
&lt;p&gt;管理Fragment的生命周期就像管理Activity的生命周期。就像一个Activity一样，Fragment也有三种状态：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Resumed
Fragment在运行的Activity中处于可见状态&lt;/li&gt;
  &lt;li&gt;Paused
另一个Activity处于前台并且获得了焦点，但是宿主Activity仍然处于可见状态（前台Activity部分透明或者没有覆盖整个屏幕）。&lt;/li&gt;
  &lt;li&gt;Stopped
Fragment完全不可见。宿主Activity已经停止了或者Fragment已经从Activity中移除但是被添加到了返回栈中。处于停止状态的Fragment仍然是活着的（所有的状态和成员信息被系统保留）。但是，它不再对用户可见，如果宿主Activity被杀，它也会被杀。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;像Activity一样，我们能够使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Bundle&lt;/code&gt;保留Fragment的状态，如果Activity进程被杀死，当Activity重新创建时，我们需要恢复Fragment的状态。我们可以在Fragment的&lt;code class=&quot;highlighter-rouge&quot;&gt; onSaveInstanceState()&lt;/code&gt;期间保存状态，然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreateView()&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;onActivityCreated()&lt;/code&gt;期间恢复。&lt;/p&gt;

&lt;p&gt;Activity与Fragment之间最重要的不同在于两者在返回栈的保存方式。Activity被放置在由系统管理的返回栈中（ &lt;a href=&quot;https://developer.android.com/guide/components/tasks-and-back-stack.html&quot;&gt;Tasks and Back Stack&lt;/a&gt;）。然而，Fragment被放置在由宿主Activity管理的返回栈中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果我们需要一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Context&lt;/code&gt;对象，我们可以调用&lt;code class=&quot;highlighter-rouge&quot;&gt;getActivity()&lt;/code&gt;方法。但是，仅仅当Fragment已经附加到Activity上时才可以。放Fragment还没有附上时，或者已经解除附加，&lt;code class=&quot;highlighter-rouge&quot;&gt;getActivity()&lt;/code&gt;会返回null。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;271-与activity生命周期的联系&quot;&gt;2.7.1 与Activity生命周期的联系&lt;/h4&gt;
&lt;p&gt;Fragment所在的Activity的生命周期会直接影响到Fragment的生命周期，每一个Activity的生命周期回调都会导致Fragment的相似的回调。
Fragment还有少许额外的生命周期回调，它处理与Activity的独特交互，以执行诸如构建和销毁Fragment UI的动作。下面是这些回调：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;onAttach()
当Fragment已经和Activity产生了关联时调用&lt;/li&gt;
  &lt;li&gt;onCreateView()
当创建Fragment的视图时调用&lt;/li&gt;
  &lt;li&gt;onActivityCreated()
当Activity的&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate&lt;/code&gt;方法返回之后调用&lt;/li&gt;
  &lt;li&gt;onDestroyView()
当Fragment的视图正在被移除时调用&lt;/li&gt;
  &lt;li&gt;onDetach()
当Fragment正在与Activity解除关联时调用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2525608-5aa9349477ebea27.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;activity_fragment_lifecycle.png&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;28-fragment嵌套fragment的生命周期&quot;&gt;2.8 Fragment嵌套Fragment的生命周期&lt;/h3&gt;
&lt;p&gt;有时候，我们有这样的需求:MainActivity有三个tab页，其中有个tab有两种显示样式，比如日历样式与列表样式。点击tab中的某个按钮，可以切换样式。
我们可以使用一个空壳子Fragment A来作为tab的Fragment，然后在里面创建两个Fragment B、C，动态的替换A里面的Fragment。这样达到了我们的目的。
然后我们又需要Fragment B、C每次可见的时候（比如从别的tab页切回来、进入一个Activity后退回来，从别的样式的Fragment切回来）刷新数据。这时候我们需要知道这些操作哪些方法被回调了。&lt;/p&gt;

&lt;p&gt;当这个tab是第二个tab时：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;点击tab2 &lt;strong&gt;setUserVisibleHint(boolean isVisibleToUser)&lt;/strong&gt;
A isVisibleToUser = [true]
页面切换 &lt;strong&gt;onHiddenChanged(boolean hidden)&lt;/strong&gt;
B onHiddenChanged  false
C onHiddenChanged  true
从别的页面回来  &lt;strong&gt;onStart&lt;/strong&gt;
B onStart
C onStart&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>刘扬窑Yorek</name></author><category term="Content Providers" /><category term="Fragment" /><summary type="html">本章的主要内容是Content Providers以及Fragment</summary></entry><entry><title type="html">Android四大组件(3)</title><link href="http://localhost:4000/android%20sdk/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6(3)/" rel="alternate" type="text/html" title="Android四大组件(3)" /><published>2017-12-18T00:00:00+08:00</published><updated>2017-12-18T00:00:00+08:00</updated><id>http://localhost:4000/android%20sdk/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6(3)</id><content type="html" xml:base="http://localhost:4000/android%20sdk/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6(3)/">&lt;p&gt;本章的主要内容是&lt;a href=&quot;https://developer.android.com/guide/components/broadcasts.html&quot;&gt;Broadcasts&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Broadcasts是一种通讯组件，Android应用程序可以发送或接收来自Android系统和其他Android应用程序的广播消息，类似于观察者设计模式。当感兴趣的事件发生时，这些广播被发送。例如，当各种系统事件（例如系统启动或设备开始充电）发生时，Android系统会发送广播。应用程序还可以发送自定义广播，例如，通知其他应用程序可能感兴趣的内容（例如，一些新数据已被下载）。&lt;/p&gt;

&lt;h2 id=&quot;1-系统广播&quot;&gt;1 系统广播&lt;/h2&gt;
&lt;p&gt;系统广播的action的列表，可以在SDK中找到，目录是&lt;code class=&quot;highlighter-rouge&quot;&gt;platforms/android-25/data/broadcast_actions.txt&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;11-系统广播的变更&quot;&gt;1.1 系统广播的变更&lt;/h3&gt;
&lt;p&gt;Android 7.0及以上平台不可以发送以下系统广播，该项优化影响所有的应用，不仅仅是目标为Android 7.0的应用：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ACTION_NEW_PICTURE&lt;/li&gt;
  &lt;li&gt;ACTION_NEW_VIDEO&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;应用目标为Android 7.0 (API level 24)及更高平台必须动态注册以下广播，静态注册无效：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;CONNECTIVITY_ACTION&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-广播的注册&quot;&gt;2 广播的注册&lt;/h2&gt;
&lt;p&gt;应用可以有两种方式注册BroadcastReceiver，第一种为在manifest中注册的静态注册，第二种为通过context在代码中注册的动态注册。&lt;/p&gt;

&lt;h3 id=&quot;21-静态注册&quot;&gt;2.1 静态注册&lt;/h3&gt;
&lt;p&gt;通过静态注册的receiver，在应用安装时系统包管理器会注册此receiver。此receiver会变成应用的一个独立入口点，这意味着如果应用没有正在运行，系统可以启动应用然后在传递广播。
系统会创建新的BroadcastReceiver组件处理每一个接收到的广播。该对象仅仅在调用&lt;code class=&quot;highlighter-rouge&quot;&gt;onReceive(Context, Intent)&lt;/code&gt;方法期间才是合法的，一旦该方法返回了，系统会认为此组件不再是active状态。&lt;/p&gt;

&lt;h3 id=&quot;22-动态注册&quot;&gt;2.2 动态注册&lt;/h3&gt;
&lt;p&gt;动态注册时需要注意，不再需要该接受者或者context不再合法时&lt;code class=&quot;highlighter-rouge&quot;&gt;unregisterReceiver&lt;/code&gt;。
动态注册的广播接收者只要它们注册的上下文有效就一直接收广播。例如，如果用Activity的context注册，主要Activity不被销毁，你就可以接收广播。如果使用Application的context，应用在运行时都可以接收广播。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;onReceive&lt;/code&gt;中不易进行耗时操作，其最长只有10s的周期。如果需要多一点点时间执行作业的话，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;goAsync()&lt;/code&gt;或者启动&lt;code class=&quot;highlighter-rouge&quot;&gt;JobSchedule&lt;/code&gt;&lt;/li&gt;
    &lt;li&gt;如果只需要应用内广播，可以使用本地广播&lt;code class=&quot;highlighter-rouge&quot;&gt;LocalBroadcastManager.registerReceiver(BroadcastReceiver, IntentFilter)&lt;/code&gt;来替代。&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;3-广播的发送&quot;&gt;3 广播的发送&lt;/h2&gt;
&lt;p&gt;Android提供了四种广播的发送方式：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sendOrderedBroadcast(Intent, String)&lt;/code&gt;发送有序广播
该广播一次发送给一个接受者，每个接受者轮流执行，该广播可以携带结果给下一个接受者，或者被接受者丢弃，这样就不会传递给下一个接受者了。接受者的顺序按照&lt;code class=&quot;highlighter-rouge&quot;&gt;android:priority&lt;/code&gt;排列，同一优先级的广播接收者将会无序执行。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sendBroadcast(Intent)&lt;/code&gt;发送普通广播&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sendStickyBroadcast&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;sendStickyOrderedBroadcast&lt;/code&gt;发送粘性广播，不过此类广播由于不安全（都能访问）、没有保护（都能修改）以及其他的问题，已经被弃用了。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;LocalBroadcastManager.sendBroadcast&lt;/code&gt;发送本地广播
在不需要发送跨app广播时，发送本地广播是最佳的选择。第一，其效率比较高(因为不用考虑IPC)；第二，也不用当心其他应用接收或者发送该广播而导致的安全性问题。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;如果想要只发送广播给特定的应用，可以使用Intent的&lt;code class=&quot;highlighter-rouge&quot;&gt;setPackage(String)&lt;/code&gt;方法&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;4-使用权限限制广播&quot;&gt;4 使用权限限制广播&lt;/h2&gt;
&lt;h3 id=&quot;41-带权限发送&quot;&gt;4.1 带权限发送&lt;/h3&gt;
&lt;p&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;sendBroadcast(Intent, String)&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;sendOrderedBroadcast(Intent, String, BroadcastReceiver，Handler, int, String, Bundle)&lt;/code&gt;时，可以指定权限参数。 只有已经请求了标签中的权限标签（或者因为是危险权限后面被运行时授予的权限）的接收者才可以接收广播。 
例如，下面代码发送广播：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sendBroadcast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;com.example.NOTIFY&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Manifest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;permission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SEND_SMS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;要接收广播，接收应用程序必须如下所示请求权限：&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;uses-permission&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;android：&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name =&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;“android.permission.SEND_SMS”/&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;可以指定现有的系统权限，如SEND_SMS或定义一个自定义权限 &lt;permission&gt;元素。&lt;/permission&gt;&lt;/p&gt;

&lt;h3 id=&quot;42-带权限接收&quot;&gt;4.2 带权限接收&lt;/h3&gt;
&lt;p&gt;当注册广播接收者(无论是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;registerReceiver(BroadcastReceiver, IntentFilter, String, Handler)&lt;/code&gt;注册还是通过在manifest文件&lt;receiver&gt;标签中)，特别申明一个权限参数时，只有已经请求了标签中的权限标签（或者因为是危险权限后面被运行时授予的权限）的接收者才可以发送广播。 
例如，假设接收广播的应用已经在manifest文件中声明了如下receiver：&lt;/receiver&gt;&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;receiver&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;.MyBroadcastReceiver&quot;&lt;/span&gt;&lt;span class=&quot;err&quot;&gt; &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;android:permission=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android.permission.SEND_SMS&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;intent-filter&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;action&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android.intent.action.AIRPLANE_MODE&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;    
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/intent-filter&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/receiver&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;或者通过动态注册的receiver有如下代码：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;IntentFilter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IntentFilter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;ACTION_AIRPLANE_MODE_CHANGED&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;registerReceiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;receiver&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;filter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Manifest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;permission&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;SEND_SMS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;为了能够发射广播到这些receivers，发射应用必须请求下面的权限：&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;uses-permission&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android.permission.SEND_SMS&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>刘扬窑Yorek</name></author><category term="Broadcasts" /><summary type="html">本章的主要内容是Broadcasts</summary></entry><entry><title type="html">Android四大组件(2)</title><link href="http://localhost:4000/android%20sdk/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6(2)/" rel="alternate" type="text/html" title="Android四大组件(2)" /><published>2017-12-18T00:00:00+08:00</published><updated>2017-12-18T00:00:00+08:00</updated><id>http://localhost:4000/android%20sdk/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6(2)</id><content type="html" xml:base="http://localhost:4000/android%20sdk/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6(2)/">&lt;p&gt;本章的主要角色是&lt;a href=&quot;https://developer.android.com/guide/components/services.html&quot;&gt;Service&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;Service是一种能够在后台执行长期运行操作的组件，它并没有UI界面。所有应用都可以开启一个Service，甚至当用户切换其他应用时，它也能继续在后台运行。另外，别的组件可以跟一个Service绑定，甚至可以执行IPC操作。比如，Service可以处理网络事务、播放音乐、处理文件I/O，或者与一个content provider交互，这一切都在后台运行。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注意：Service运行在宿主进程的主线程中。Service并不会创建自己的线程，在没有特别申明的情况下也不会运行在分离的进程中。如果你的Service打算执行消耗CPU的工作或者阻塞的操作，比如播放MP3或网络操作等，你应该在Service内创建新的线程。这能减少ANR的风险，主线程也能专心与处于UI事务。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;1-service的类型&quot;&gt;1 Service的类型&lt;/h2&gt;
&lt;p&gt;现在有三种类型的Service，主要说后面两种。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Scheduled
Google强烈推荐在Android 5.0 (API level 21)或以上上面，使用&lt;a href=&quot;https://developer.android.com/reference/android/app/job/JobScheduler.html&quot;&gt;JobScheduler&lt;/a&gt;来启动Service，系统会在合适的时间优雅的按计划执行这些任务。&lt;/li&gt;
  &lt;li&gt;Started 启动状态
当一个应用组件调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;startService&lt;/code&gt;时，Service会处于启动状态。当Service启动后，它能够无期限的运行在后台，甚至开启该Service的组件已经销毁了。通常，处于启动状态的Service执行单一的操作，而且不返回操作结果给调用者。比如，从网络下载文件。当任务完成后，Service应该停止它本身。可以在Service内部调用&lt;code class=&quot;highlighter-rouge&quot;&gt;stopSelf()&lt;/code&gt;或者其他组件调用&lt;code class=&quot;highlighter-rouge&quot;&gt;stopService()&lt;/code&gt;来终止Service。&lt;/li&gt;
  &lt;li&gt;Bound 绑定状态
当一个应用组件调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;bindService&lt;/code&gt;时，Service会处于绑定状态。处于绑定状态的Service提供了一个允许其他组件与该Service交互的C/S接口，这些交互可能是发送请求，接收数据，甚至执行IPC操作。只要其他应用组件绑定了他，它就会开始运行。多个组件能绑定到一个Service实例上，当它们都解绑时，此Service实例就会销毁。&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;启动状态与绑定状态不是互斥的。你能绑定一个以&lt;code class=&quot;highlighter-rouge&quot;&gt;startService()&lt;/code&gt;启动的Service。比如，你可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;startService()&lt;/code&gt;启动一个Service播放音乐。然后，用户可能想切歌或者获取当前歌曲的信息，此时Activity可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;bindService()&lt;/code&gt;绑定到该Service。这种情况下，事实上直到客户端解绑，&lt;code class=&quot;highlighter-rouge&quot;&gt;stopService()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;stopSelf()&lt;/code&gt;才能停止Service。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;2-service的生命周期方法&quot;&gt;2 Service的生命周期方法&lt;/h2&gt;
&lt;p&gt;Service主要有四个生命周期方法：&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;onStartCommand()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;onBind()&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;onDestroy()&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;onCreate()
Service第一次创建时，系统会调用此方法进行一次性初始化设置。调用时间在&lt;code class=&quot;highlighter-rouge&quot;&gt;onStartCommand&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;onBind&lt;/code&gt;之前。如果该Service已经处于运行状态，此方法不会调用。&lt;/li&gt;
  &lt;li&gt;onStartCommand()
当其他组件(比如Activity)通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;startService&lt;/code&gt;来请求Service启动时，系统会调用此方法。该方法执行时，Service将启动并可以无限期地在后台运行。如果实现了此功能，那么通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;stopSelf()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;stopService()&lt;/code&gt;来停止其工作是很有必要的。如果只想提供绑定功能，则不需要实现此方法。
onStartCommand()有三种返回值：
    &lt;ul&gt;
      &lt;li&gt;START_NOT_STICKY
如果系统在&lt;code class=&quot;highlighter-rouge&quot;&gt;onStartCommand()&lt;/code&gt;方法返回之后杀死这个服务，那么直到接受到新的Intent对象，这个服务才会被重新创建。这是最安全的选项，用来避免在不需要的时候运行你的服务。&lt;/li&gt;
      &lt;li&gt;START_STICKY
如果系统在&lt;code class=&quot;highlighter-rouge&quot;&gt;onStartCommand()&lt;/code&gt;返回后杀死了这个服务，系统就会重新创建这个服务并且调用&lt;code class=&quot;highlighter-rouge&quot;&gt;onStartCommand()&lt;/code&gt;方法，但是它不会重新传递最后的Intent对象，系统会用一个null的Intent对象来调用&lt;code class=&quot;highlighter-rouge&quot;&gt;onStartCommand()&lt;/code&gt;方法，在这个情况下，除非有一些被发送的Intent对象在等待启动服务。这适用于不执行命令的媒体播放器（或类似的服务），它只是无限期的运行着并等待工作的到来。&lt;/li&gt;
      &lt;li&gt;START_REDELIVER_INTENT
如果系统在&lt;code class=&quot;highlighter-rouge&quot;&gt;onStartCommand()&lt;/code&gt;方法返回后，系统就会重新创建了这个服务，并且用发送给这个服务的最后的Intent对象调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;onStartCommand()&lt;/code&gt;方法。任意等待中的Intent对象会依次被发送。这适用于那些应该立即恢复正在执行的工作的服务，如下载文件。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;onBind()
当其他组件想要通过调用&lt;code class=&quot;highlighter-rouge&quot;&gt;bindService()&lt;/code&gt;与Service绑定（例如执行RPC）时，系统会调用此方法。 在实现此方法时，必须返回IBinder对象给客户端，使客户端可以与Service进行通信。这个方法是必须要实现的， 如果不支持绑定，可以直接返回null。同时，对于支持绑定的Service，可以在此方法中进行验证，如果验证失败，可以返回null，这样客户端绑定不上。&lt;/li&gt;
  &lt;li&gt;onDestroy()
当Service不在使用时，系统会调用此方法。可以在此进行资源的回收，比如线程、注册过的监听器、receiver等。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-service的生命周期&quot;&gt;3 Service的生命周期&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2525608-4b3666a8cccfa8f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;service_lifecycle.png&quot; /&gt;
Service也有两个主要的生命周期循环：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;完整的生命周期&lt;/strong&gt;：从&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate&lt;/code&gt;调用开始，到&lt;code class=&quot;highlighter-rouge&quot;&gt;onDestroy&lt;/code&gt;返回为止。像Activity一样，Service可以做一些初始化设置在&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate&lt;/code&gt;方法中，然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;onDestroy&lt;/code&gt;中释放所有剩余的资源。比如音乐播放Service，可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate&lt;/code&gt;中创建音乐播放线程，然后在&lt;code class=&quot;highlighter-rouge&quot;&gt;onDestroy&lt;/code&gt;中停止线程。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;活动的生命周期&lt;/strong&gt;：开始于对&lt;code class=&quot;highlighter-rouge&quot;&gt;onStartCommand()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;onBind()&lt;/code&gt;的调用。如果服务启动，则活动生命周期将在完整生命周期结束的同时结束（即使在&lt;code class=&quot;highlighter-rouge&quot;&gt;onStartCommand()&lt;/code&gt;返回后，该服务仍然处于活动状态）。如果服务被绑定，当&lt;code class=&quot;highlighter-rouge&quot;&gt;onUnbind()&lt;/code&gt;返回时，活动生命周期结束。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于已经处于active状态的Service，再次通过&lt;code class=&quot;highlighter-rouge&quot;&gt;startService&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;bindService&lt;/code&gt;来启动同一个Service，其&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate&lt;/code&gt;不会再次调用，而是直接调用对应的&lt;code class=&quot;highlighter-rouge&quot;&gt;onStartCommand()&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;onBind()&lt;/code&gt;方法。&lt;/p&gt;

&lt;h2 id=&quot;4-intentservice&quot;&gt;4 IntentService&lt;/h2&gt;
&lt;p&gt;IntentService是使用一个工作线程串行(one at a time)处理所有开始请求的Service的子类。如果你的Service不需要同时处理多个请求的话，这是最好的选择。仅仅需要实现&lt;code class=&quot;highlighter-rouge&quot;&gt;onHandleIntent()&lt;/code&gt;方法来完成&lt;code class=&quot;highlighter-rouge&quot;&gt;onStartCommand()&lt;/code&gt;接收到Intent后分发过来的请求。
IntentService有以下特点：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;它创建一个默认的工作线程，此工作线程用来处理Service接收到的Intent请求。&lt;/li&gt;
  &lt;li&gt;工作线程由HandlerThread+用来将Intent分发给&lt;code class=&quot;highlighter-rouge&quot;&gt;onHandleIntent()&lt;/code&gt;方法的Handler实例组成。&lt;/li&gt;
  &lt;li&gt;在所有的开始请求执行完成后，会自动调用&lt;code class=&quot;highlighter-rouge&quot;&gt;stopSelf()&lt;/code&gt;方法，因此不需要自己手动调用。&lt;/li&gt;
  &lt;li&gt;提供默认的会返回null的&lt;code class=&quot;highlighter-rouge&quot;&gt;onBind()&lt;/code&gt;方法。&lt;/li&gt;
  &lt;li&gt;提供&lt;code class=&quot;highlighter-rouge&quot;&gt;onStartCommand()&lt;/code&gt;的默认实现，它将Intent发送到工作队列，然后转发到&lt;code class=&quot;highlighter-rouge&quot;&gt;onHandleIntent()&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这就是实现一个IntentService所需要的：一个构造函数和一个&lt;code class=&quot;highlighter-rouge&quot;&gt;onHandleIntent()&lt;/code&gt;的实现。 如果要覆盖其他回调方法，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;onCreate()&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;onStartCommand()&lt;/code&gt;或&lt;code class=&quot;highlighter-rouge&quot;&gt;onDestroy()&lt;/code&gt;，要调用父类的实现，以便IntentService可以正确处理工作线程的生命周期。当Service需要提供绑定状态时，你需要重写&lt;code class=&quot;highlighter-rouge&quot;&gt;onBind()&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;关于IntentService的源码部分，可以查看另外一篇文章：&lt;a href=&quot;http://www.jianshu.com/p/d6d599f764cf&quot;&gt;Android线程与线程池&lt;/a&gt;&lt;/p&gt;</content><author><name>刘扬窑Yorek</name></author><category term="Service" /><summary type="html">本章的主要角色是Service。</summary></entry><entry><title type="html">Android四大组件(1)</title><link href="http://localhost:4000/android%20sdk/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6(1)/" rel="alternate" type="text/html" title="Android四大组件(1)" /><published>2017-12-18T00:00:00+08:00</published><updated>2017-12-18T00:00:00+08:00</updated><id>http://localhost:4000/android%20sdk/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6(1)</id><content type="html" xml:base="http://localhost:4000/android%20sdk/Android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6(1)/">&lt;p&gt;Android四大组件分别是Activity、Service、ContentProvider以及BroadcastReceiver。&lt;/p&gt;

&lt;p&gt;其中，Activity是使用最频繁的一个组件，可以翻译为界面。当然，我们常见的界面除了Activity，还有Window(这里指悬浮窗，类似于360的悬浮球)、Dialog以及Toast。Android中所有的视图都是通过Window来呈现的。&lt;/p&gt;

&lt;p&gt;关于Fragment，可以查看&lt;a href=&quot;http://www.jianshu.com/p/41696ae40906&quot;&gt;Android四大组件(4)&lt;/a&gt;。两者一起看能更好的了解彼此。&lt;/p&gt;

&lt;p&gt;本章的主要内容有：Activity生命周期、启动模式、IntentFilter匹配规则。&lt;/p&gt;

&lt;p&gt;英语好的可以直接看&lt;a href=&quot;https://developer.android.com/reference/android/app/Activity.html&quot;&gt;google官方文档&lt;/a&gt;，讲的更多更细。&lt;/p&gt;

&lt;h2 id=&quot;1-activity的生命周期&quot;&gt;1 Activity的生命周期&lt;/h2&gt;
&lt;p&gt;Activity的生命周期分为两个部分：正常情况、异常情况。
所谓正常情况就是指在用户的参与下经历的生命周期的改变；而异常情况是指Activity因RAM不足被LMK杀死或者由于的Configuration(比如横竖屏切换、语言改变等)改变导致Activity销毁重构。&lt;/p&gt;

&lt;h3 id=&quot;11-正常情况下activity的生命周期&quot;&gt;1.1 正常情况下Activity的生命周期&lt;/h3&gt;
&lt;p&gt;如图，是正常情况下Activity所经历的生命周期。
&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/2525608-aff866a076421fe2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;activity_lifecycle&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;onCreate：当Activity第一次创建的时候调用。在这里，我们做一些初始化工作：加载布局、初始化Activity所需要的数据等。&lt;/li&gt;
  &lt;li&gt;onRestart：Activity重新启动。当Activity从不可见重新变成可见状态时，此方法会被调用。&lt;/li&gt;
  &lt;li&gt;onStart：表示Activity正在启动，当Activity正在变成可见状态时会被调用。&lt;/li&gt;
  &lt;li&gt;onResume：表示Activity已经可见了，且出现在前台可与用户进行交互。&lt;/li&gt;
  &lt;li&gt;onPause：Activity正在停止。此时可以提交未保存的数据、停止动画或其他可能消耗CPU资源的操作。在此方法中不能执行耗时操作，因为下一个Activity不会调用onResume直到该方法执行完。&lt;/li&gt;
  &lt;li&gt;onStop：Activity即将停止，当Activity不在可见时调用，因为另一个Activity已经调用了onResume，并且覆盖了这个Activity。&lt;/li&gt;
  &lt;li&gt;onDestroy：Activity即将被销毁。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在Activity的生命周期中有三个关键的循环：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;完整生命周期：第一次调用onCreate ~ 最终调用onDestory
我们可以在onCreate中初始化所有数据，在onDestroy中释放。比如后台下载数据的线程。&lt;/li&gt;
  &lt;li&gt;可见生命周期：onStart ~ onStop
在此期间，用户可以看到Activity在屏幕上，但是并不在前台，因此也不能与用户进行交互。在着两个方法里可以维护需要展示给用户的资源。比如在onStart里面注册BroadcastReceiver，在onStop里面unregister。onStart、onStop会根据Activity对用户的显示、隐藏可以调用多次。&lt;/li&gt;
  &lt;li&gt;前台生命周期：onResume ~ onPause
在此期间，Activity在所有其他activity的上面，可以与用户进行交互。
一个activity可以频繁的经历resumed和paused状态，比如设备休眠，activity的结果返回了，接收到了新的intent等等。因此，在这两个方法里面的代码应该要非常轻量。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;如果Activity A启动B，那么A和B的生命周期的生命周期调用顺序怎么样呢？&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;A:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onPause&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;called&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;B:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;called&lt;/span&gt; &lt;span class=&quot;nl&quot;&gt;with:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;savedInstanceState&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;B:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onStart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;called&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;B:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onResume&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;called&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;D&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;A:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;onStop&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;called&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;很显然，Android系统只允许一个Activity出现在前台，因此会先执行A的onPause方法使A退出前台，然后在执行B启动过程使其出现在前台，最后在调用A的onStop方法。&lt;/p&gt;

&lt;h3 id=&quot;12-异常情况下activity的生命周期&quot;&gt;1.2 异常情况下Activity的生命周期&lt;/h3&gt;
&lt;h4 id=&quot;121-资源发生了改变&quot;&gt;1.2.1 资源发生了改变&lt;/h4&gt;
&lt;p&gt;在默认情况下，系统配置改变将会导致当前的activity被销毁，该activity会经历正常的生命周期方法，onPause、onStop、onDestroy会被调用。如果此activity在前台或者用户可见，此activity会在onDestroy调用后被重新创建。
由于activity是异常终止的，所以系统会调用onSaveInstanceState(Bundle)保存当前activity的状态，当activity被重新创建后，会调用onRestoreInstanceState；此外重构时Bundle也会传入onCreate方法中。
&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;onSaveInstanceState&lt;/code&gt;将会调用在&lt;code class=&quot;highlighter-rouge&quot;&gt;onStop&lt;/code&gt;之前，与onPause没有时序关系。&lt;code class=&quot;highlighter-rouge&quot;&gt;onRestoreInstanceState&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;onStart&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;onPostCreate&lt;/code&gt;之间被调用。&lt;code class=&quot;highlighter-rouge&quot;&gt;onPostCreate&lt;/code&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;onResume&lt;/code&gt;之前调用。&lt;/strong&gt;
另外，在资源改变导致重新创建时，系统自动为我们做了一些恢复工作。具体某个特定的View能够为我们恢复哪些数据，可以查看View的这两个方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;上面我们提到，在默认情况下，系统配置改变将会导致当前的activity被销毁重建，那怎么阻止该过程的发生呢？&lt;/strong&gt;
我们可以通过配置activity的configChanges属性达到目的。比如我们不想屏幕旋转时重新创建，可以在activity添加configChanges=”orientation”，如果我们想指定多个值，可以通过或操作”|”连接起来，比如”mcc|mnc”
&lt;a href=&quot;https://developer.android.com/reference/android/R.attr.html#configChanges&quot;&gt;所有的config以及解释，需要翻墙&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;横竖屏切换生命周期？&lt;/strong&gt;
网上流传的横屏切换回竖屏生命周期执行两次，我看到了就觉得比较可疑。然后自己试验了下，也找了资料。现在完全不是这么回事了。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;只设置configChanges=”orientation”和不设置这个属性，Activity都会销毁重建&lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;设置configChanges=”orientation&lt;/td&gt;
          &lt;td&gt;keyboardHidden”，在Android 2.3上不会重建，超过会重建&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;设置configChanges=”orientation&lt;/td&gt;
          &lt;td&gt;screenSize”时，在Android 4.0以上不会重建&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;122-内存不足导致低优先级的activity被杀死&quot;&gt;1.2.2 内存不足导致低优先级的activity被杀死&lt;/h4&gt;
&lt;p&gt;这种情况下activity的数据存储、恢复的过程和1完全一样。当系统资源不足时，系统会按照activity的优先级顺序来杀死目标Activity所在的进程。Activity的优先级从高到低，可以分来三中：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;前台Activity —— 正在和用户进行交互，处于running状态&lt;/li&gt;
  &lt;li&gt;可见但非前台 —— 比如Activity弹出了一个对话框&lt;/li&gt;
  &lt;li&gt;后台Activity —— 已经执行了onStop
  因此，后台工作不适合脱离四大组件而独自运行，这样容易被杀死。比较好的方式是将后台任务放入Service中，这样能保证进程有一定的优先级。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;2-activity的启动模式&quot;&gt;2 Activity的启动模式&lt;/h2&gt;
&lt;p&gt;本节的主要内容有：Activity的LaunchMode以及Flags&lt;/p&gt;

&lt;h3 id=&quot;21-launchmode&quot;&gt;2.1 LaunchMode&lt;/h3&gt;
&lt;p&gt;目前有四种启动模式：standard、singleTop、singleTask、singleInstance&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;standard
默认的启动模式。每次启动activity都会创建一个新的实例，不管该实例是否已经存在。被启动的activity会运行在启动该activity的任务栈中。所以使用非Activity类型的Context启动一个standard Activity就会报错，解决该问题的办法是为待启动的Activity指定FLAG_ACTIVITY_NEW_TASK，这样启动的时候就会为它准备一个新的任务栈，这样待启动Activity实际上是以singleTask模式启动的。&lt;/li&gt;
  &lt;li&gt;singleTop
栈顶复用模式。如果Activity已经位于任务栈的栈顶，那么Activity不会重新创建，同时其onNewIntent方法会被回调。&lt;/li&gt;
  &lt;li&gt;singleTask
栈内复用模式。这是一种单实例模式，只要Activity在一个栈中存在，多起启动该Activity都不会重新创建实例，和singleTop一样，系统会回调其onNewIntent方法。同时，位于该Activity上面的Activity都会被出栈，所以该启动模式具有FLAG_ACTIVITY_CLEAR_TOP效果。&lt;/li&gt;
  &lt;li&gt;singleInstance
单实例模式。加强版的singleTask，它具有singleTask的一些特点，此外，还强调了一点：具有该模式的Activity只能单独的位于一个任务栈中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;22-任务栈&quot;&gt;2.2 任务栈&lt;/h3&gt;
&lt;p&gt;任务栈分为前台任务栈和后台任务栈，后台任务栈中的activity处于暂停状态，用户可以通过操作将后台任务栈再次调回前台。
可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;adb shell dumpsys activity&lt;/code&gt;查看任务栈信息，信息在&lt;code class=&quot;highlighter-rouge&quot;&gt;Running activities (most recent first)&lt;/code&gt;这一栏中。
在activity中有一个属性可以标记该activity运行在哪个任务栈中，这个属性就是android:taskAffinity。taskAffinity必须为字符串，且中间必须含有包名分隔符”.”。默认情况下，activity运行在应用包名的任务栈中。该属性主要用在singleTask启动模式或者与allowTaskReparenting属性配对使用。
taskAffinity与singleTask连用比较好理解，而与allowTaskReparenting连用有点麻烦。allowTaskReparenting属性的意思是，当下次进入前台时，是否允许此Activity从启动它的task移动到与affinity一样的task。假设有两个应用A和B，应用A中的Activity启动了应用B中带有allowTaskReparenting属性的Activity 1，然后按HOME键回到桌面，进入B应用，会发现出现的是Activity 1，而不是应用B的主Activity。&lt;/p&gt;

&lt;h3 id=&quot;23-activity的启动方式&quot;&gt;2.3 Activity的启动方式&lt;/h3&gt;
&lt;p&gt;Activity的启动方式有两种&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;通过指定activity节点的launchMode属性&lt;/li&gt;
  &lt;li&gt;通过startActivity中Intent的addFlags方法添加标志位
两种方式的区别：
    &lt;ol&gt;
      &lt;li&gt;后者优先级会高于前者，即两种方式同时存在时，以后者为准&lt;/li&gt;
      &lt;li&gt;两种方式可使用范围不同，比如前者无法给Activity设置FLAG_ACTIVITY_CLEAR_TOP标识，后者无法为Activity指定singleInstance模式。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;24-activity的flags&quot;&gt;2.4 Activity的Flags&lt;/h3&gt;
&lt;p&gt;Activity中有些Flags可以影响Activity的启动模式，有些则可以影响Activity的运行状态。下面主要说说常见的几个标记位。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Flags&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;意义&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;FLAG_ACTIVITY_NEW_TASK&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;为Activity指定”singleTask”启动模式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;FLAG_ACTIVITY_SINGLE_TOP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;为Activity指定”singleTop”启动模式&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;FLAG_ACTIVITY_CLEAR_TOP&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;启动此Activity时，同一任务栈中所有位于它上面的Activity都会出栈。此Activity会调用onNewIntent还是重新创建与其自身启动模式有关。如果此Activity启动模式是standard，则会finish然后re-created；如果是其他的启动模式，则会调用当前实例的onNewIntent方法。与FLAG_ACTIVITY_NEW_TASK连用会使目标Activity出现在栈顶，这在有些时候是非常好用的，比如从通知栏运行Activity。&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;包含有此标记的Activity不会出现在历史Activity中，也可以使用android:excludeFromRecents=”true”属性&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;3-intentfilter的匹配规则&quot;&gt;3 IntentFilter的匹配规则&lt;/h2&gt;
&lt;p&gt;intent-filter在AndroidManifest.xml中的写法&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;intent-filter&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;action&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android.intent.action.VIEW&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;action&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android.intent.action.EDIT&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;action&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android.intent.action.PICK&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;category&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;android.intent.category.DEFAULT&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;data&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:mimeType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;vnd.android.cursor.dir/vnd.google.note&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/intent-filter&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;IntentFilter用在Activity的隐式调用上。IntentFilter中的过滤信息主要有action、category以及data。
只有一个Intent完全匹配上了action、category、data，才算匹配成功。一个Activity可以有多个intent-filter，只要一个Intent匹配成功了任何一组intent-filter就算成功匹配。
IntentFilter的匹配规则代码如下：&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// frameworks/base/core/java/android/content/IntentFilter.java&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;match&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scheme&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Uri&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;categories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;logTag&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;matchAction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_MATCH_ACTION&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataMatch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matchData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scheme&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataMatch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataMatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;categoryMismatch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matchCategories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categoryMismatch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_MATCH_CATEGORY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dataMatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;31-action的匹配规则&quot;&gt;3.1 action的匹配规则&lt;/h3&gt;
&lt;p&gt;action的匹配规则是指Intent中的action必须和intent-filter中的action匹配。一个过滤规则中可以有多个action，只要Intent中的action能够和intent-filter中任何一个action相同即可匹配成功。因此，Intent中如果没有指定action，那么匹配失败。
&lt;strong&gt;action的匹配规则要求Intent中的action必须存在且必须和过滤规则中某个action相同&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mActions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;matchAction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hasAction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;hasAction&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mActions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;32-category的匹配规则&quot;&gt;3.2 category的匹配规则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;category的匹配规则要求Intent中如果含有category，那么Intent中所有的category都必须和过滤规则中的某个category相同。&lt;/strong&gt;
如果没有添加category，系统在startActivity或者startActivityForResult时会默认加上”android.intent.category.DEFAULT”这个category，所以为了我们的Activity可以接受隐式调用，需要在intent-filter中指定”android.intent.category.DEFAULT”这个category。&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mCategories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;matchCategories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;categories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;categories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;categories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mCategories&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;hasNext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;category&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mCategories&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;category&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;category&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;33-data的匹配规则&quot;&gt;3.3 &lt;a href=&quot;https://developer.android.com/guide/topics/manifest/data-element.html&quot;&gt;data的匹配规则&lt;/a&gt;&lt;/h3&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;data&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:scheme=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;string&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;android:host=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;string&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;android:port=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;string&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;android:path=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;string&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;android:pathPattern=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;string&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;android:pathPrefix=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;string&quot;&lt;/span&gt;
      &lt;span class=&quot;na&quot;&gt;android:mimeType=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;string&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;data结构有点复杂。先说一下data的结构：data由mimeType和URI两部分组成。
mimeType指媒体类型，比如image/jpeg、image/png、audio/mpeg4-generic和video/*等。mimeType在Android framework的匹配是大小写敏感的，所以mimeType应该要使用小写字母。
而URI包含的数据由很多部分组成:
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;scheme&amp;gt;://&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;[&amp;lt;path&amp;gt;|&amp;lt;pathPrefix&amp;gt;|&amp;lt;pathPattern&amp;gt;]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;scheme：URI的模式，比如http、file、content等。缺少该部分，整个URI无效。&lt;/li&gt;
  &lt;li&gt;host：URI的主机名。缺少该部分，整个URI无效。&lt;/li&gt;
  &lt;li&gt;port：端口号，仅当URI中指定了scheme和host时，port才是有意义的。&lt;/li&gt;
  &lt;li&gt;path、pathPrefix、pathPattern：路径信息，必须以”/”开头。path表示完整信息；pathPattern也表示完成信息，但是它可以包含通配符”&lt;em&gt;“，”&lt;/em&gt;“表示0或多个前一个字符，”.&lt;em&gt;“表示匹配0或者多个任意字符。注意，由于正则表达式的规范，”&lt;/em&gt;“要被转义成”*“；pathPrefix表示路径的前缀信息。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;过滤规则中如果没有写URI，则有一个默认值：content:和file:。即Intent中的URI的scheme部分必须是content或者file才能匹配。
此外，如果Intent要指定完整的data，必须使用&lt;code class=&quot;highlighter-rouge&quot;&gt;setDataAndType&lt;/code&gt;方法，而不能调用&lt;code class=&quot;highlighter-rouge&quot;&gt;setData&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;setType&lt;/code&gt;，着两个方法会清除对方的值。
在同一个&lt;intent-filter&gt;节点下所有的&lt;data&gt;标签都作用与同一个filter，因此下面两种写法是等价的：&lt;/data&gt;&lt;/intent-filter&gt;&lt;/p&gt;
&lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;intent-filter&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;data&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:scheme=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;something&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:host=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;project.example.com&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    . . .
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/intent-filter&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;intent-filter&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;data&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:scheme=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;something&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;data&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;android:host=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;project.example.com&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    . . .
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/intent-filter&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;data的匹配规则和action类似，&lt;strong&gt;它要求Intent中必须含有data数据，并且data数据能够完全匹配过滤规则中的某个data。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;matchData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scheme&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Uri&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;types&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mDataTypes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;schemes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mDataSchemes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MATCH_CATEGORY_EMPTY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;schemes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MATCH_CATEGORY_EMPTY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MATCH_ADJUSTMENT_NORMAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_MATCH_DATA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;schemes&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;schemes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;contains&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scheme&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scheme&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MATCH_CATEGORY_SCHEME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_MATCH_DATA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PatternMatcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;schemeSpecificParts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mDataSchemeSpecificParts&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;schemeSpecificParts&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hasDataSchemeSpecificPart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getSchemeSpecificPart&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;())&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MATCH_CATEGORY_SCHEME_SPECIFIC_PART&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_MATCH_DATA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MATCH_CATEGORY_SCHEME_SPECIFIC_PART&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;c1&quot;&gt;// If there isn't any matching ssp, we need to match an authority.&lt;/span&gt;
                &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AuthorityEntry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authorities&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mDataAuthorities&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;authorities&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authMatch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;matchDataAuthority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;authMatch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PatternMatcher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;paths&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mDataPaths&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;paths&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;authMatch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hasDataPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getPath&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;n&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MATCH_CATEGORY_PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_MATCH_DATA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_MATCH_DATA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
                &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// If neither an ssp nor an authority matched, we're done.&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_MATCH_DATA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_MATCH_DATA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// Special case: match either an Intent with no data URI,&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// or with a scheme: URI.  This is to give a convenience for&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// the common case where you want to deal with data in a&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// content provider, which is done by type, and we don't want&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// to force everyone to say they handle content: or file: URIs.&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scheme&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scheme&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;content&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scheme&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;file&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scheme&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_MATCH_DATA&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;types&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;findMimeType&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MATCH_CATEGORY_TYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_MATCH_TYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// If no MIME types are specified, then we will only match against&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// an Intent that does not have a MIME type.&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NO_MATCH_TYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;match&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MATCH_ADJUSTMENT_NORMAL&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;最后，通过隐式启动Activity时，如果没有Activity能够匹配我们的隐式Intent，我们startActivity就会报错。
我们有两种方法解决：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;可以使用PackageManager或者Intent的&lt;code class=&quot;highlighter-rouge&quot;&gt;resolveActivity&lt;/code&gt;方法，如果没有匹配的Activity则会返回null。（Intent的该方法是基于PackageManager的同名方法的。）&lt;/li&gt;
  &lt;li&gt;可以使用PackageManager的&lt;code class=&quot;highlighter-rouge&quot;&gt;queryIntentActivities&lt;/code&gt;方法，该方法会返回所有成功匹配的Activity信息，而不是resolveActivity的最佳匹配。
  注意下PackageManager的第二个参数，这里要传入MATCH_DEFAULT_ONLY这个参数，这个参数的意义在于匹配声明了”android.intent.category.DEFAULT”的Activity，不然匹配上的Activity不一定可以成功启动。
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;c1&quot;&gt;// PackageManager&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ResolveInfo&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;resolveActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; 
         &lt;span class=&quot;nd&quot;&gt;@ResolveInfoFlags&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ResolveInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;queryIntentActivities&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intent&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;intent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
         &lt;span class=&quot;nd&quot;&gt;@ResolveInfoFlags&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

 &lt;span class=&quot;c1&quot;&gt;// Intent&lt;/span&gt;
 &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ComponentName&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;resolveActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PackageManager&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mComponent&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mComponent&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

     &lt;span class=&quot;n&quot;&gt;ResolveInfo&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;resolveActivity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PackageManager&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;MATCH_DEFAULT_ONLY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ComponentName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
                 &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;activityInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;applicationInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;packageName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt;
                 &lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;activityInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>刘扬窑Yorek</name></author><category term="Activity" /><summary type="html">Android四大组件分别是Activity、Service、ContentProvider以及BroadcastReceiver。</summary></entry></feed>